	<!DOCTYPE html>
	<html lang="pt-BR">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Planificação Econômica Democrática com Otimização</title>
		<link rel="icon" href="./favicon.ico" type="image/x-icon">
		<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.10.1/math.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
		<script src="https://cdn.jsdelivr.net/gh/davidshimjs/qrcodejs/qrcode.min.js"></script>
		<style>
			
		@font-face {
		font-family: 'Ethnocentric Rg';
		src: url('Ethnocentric Rg.woff2') format('woff2'),
			 url('Ethnocentric Rg.woff') format('woff'),
			 url('Ethnocentric Rg.ttf') format('truetype');
		font-display: swap; /* Garante que o texto é exibido enquanto a fonte carrega */
	}
			
		body {
			margin: 0;
			position: relative;
		}


	body::before {
		content: "";
		position: fixed;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		background: url('https://i.postimg.cc/mkZcFJ6g/backgroundcibercomunismo-0-NHja4-Lah-transformed.jpg') no-repeat center center;
		background-size: cover;
		z-index: -1;
		animation: pulse-brightness 30s infinite;
		will-change: background-position; /* Otimiza a performance */
		background-attachment: fixed; /* Garante a fixação do fundo */
		background-position: center calc(var(--background-offset, 0%));
	}
			
			@keyframes pulse-brightness {
				0%, 100% {
					filter: brightness(0.9); /* Brilho normal */
				}
				50% {
					filter: brightness(1.7); /* Brilho aumentado */
				}
			}
			
			h1, h2 {
			color: #333;
			display: flex;
			align-items: center; /* Centraliza verticalmente */
			font-family: 'Ethnocentric Rg', 'Courier New', Courier, monospace; !important;
			font-size: 20px; /* Ajuste o tamanho conforme necessário */
			font-weight: normal;
			}
			
			
			table {
		background-color: rgba(100, 0, 0, 0.6) !important; /* Fundo vermelho escuro semi-transparente */
		color: white !important; /* Texto branco para contraste */
		border-collapse: collapse; /* Mescla bordas */
		width: 100%; /* Garante que a tabela ocupe toda a largura disponível */
		margin-top: 20px; /* Espaçamento superior */
	}

	th, td {
		background-color: rgba(100, 0, 0, 0.5) !important; /* Fundo mais transparente para células */
		color: white !important; /* Texto branco */
		border: 1px solid rgba(255, 255, 255, 0.6); /* Bordas brancas semi-transparentes */
		padding: 8px; /* Espaçamento interno */
		text-align: center; /* Centraliza o texto */
	}

	th {
		background-color: rgba(100, 0, 0, 0.7) !important; /* Fundo menos transparente para cabeçalhos */
	}
			
			button { padding: 10px 20px; margin: 10px 0; background-color: #007bff; color: white; border: none; cursor: pointer; }
			input[type="number"] { width: 80px; }
			input[type="text"] { width: 100%; }
			.demand-field { display: flex; align-items: center; margin-bottom: 10px; }
			.demand-field label { margin-right: 10px; font-weight: bold; }
			.modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); }
			.modal-content { background-color: white; margin: 10% auto; padding: 20px; width: 400px; border-radius: 8px; }
			
			/* Estilo padrão para os botões */
			button {
				transition: filter 0.3s ease, box-shadow 0.3s ease; /* Adiciona uma transição suave */
			}

			/* Efeito de brilho ao passar o mouse */
			button:hover {
				filter: brightness(1.5); /* Aumenta o brilho*/
				box-shadow: 0 0 10px rgba(255, 150, 150, 0.5); /* Adiciona uma leve luz ao redor */
				cursor: pointer; /* Indica interatividade */
			}
			
			/* Estilo do modal de boas-vindas */
	.modal {
		display: none; /* Inicialmente escondido */
		position: fixed;
		z-index: 1050;
		left: 0;
		top: 0;
		width: 100%;
		height: 100%;
		background-color: rgba(0, 0, 0, 0.8); /* Fundo escuro semi-transparente */
		display: flex;
		justify-content: center;
		align-items: center;
		overflow-y: auto; /* Permite rolagem vertical em telas pequenas */
	}

	/* Estilo geral das janelas modais */
	.modal-content {
		background-color: #333; /* Cor de fundo */
		color: white; /* Cor do texto */
		border-radius: 8px;
		max-width: 90%; /* Largura máxima para telas pequenas */
		max-height: 90%; /* Altura máxima para telas pequenas */
		overflow-y: auto; /* Permite rolagem interna se necessário */
		position: relative; /* Necessário para posicionar elementos internos */
		box-shadow: 0 8px 16px rgba(0, 0, 0, 0.6); /* Sombra estilosa para efeito de profundidade */
	}

	/* Barra de título da janela */
	.modal-title-bar {
		display: flex;
		align-items: center;
		justify-content: flex-start; /* Garante que o título fique alinhado à esquerda */
		background-color: rgba(100, 0, 0, 0.8); /* Cor de fundo atual */
		padding: 10px 15px;
		border-top-left-radius: 8px; /* Arredonda o canto superior esquerdo */
		border-top-right-radius: 8px; /* Arredonda o canto superior direito */
		font-size: 16px;
		font-weight: bold;
		color: white;
	}

	.modal-title-bar img {
		height: 1em; /* Alinha o tamanho da imagem ao tamanho do texto */
		margin-right: 10px; /* Espaço entre a imagem e o título */
	}


	/* Botão fechar na barra de título */
	.modal-title-bar .close {
		background: none; /* Sem fundo padrão */
		border: none;
		font-size: 18px;
		color: white; /* Cor do texto */
		cursor: pointer;
		margin-right: 10px; /* Adiciona espaçamento à direita */
		padding: 5px; /* Adiciona um espaçamento interno para melhorar o clique */
		border-radius: 3px; /* Torna as bordas do quadrado levemente arredondadas */
	}

	.modal-title-bar .close:hover {
		background-color: rgba(255, 0, 0, 0.2); /* Fundo vermelho claro ao passar o mouse */
		color: white; /* Mantém o texto branco */
	}



	.welcome-image {
		display: block; /* Garante que o GIF seja tratado como um bloco */
		margin: 0 auto; /* Centraliza o GIF horizontalmente */
		max-width: 100%; /* Ajusta o tamanho do GIF a telas pequenas */
		height: auto; /* Mantém a proporção do GIF */
	}

	/* Estilo geral do botão fechar */
	.modal-content .close {
		background: none; /* Sem fundo padrão */
		border: none;
		font-size: 18px;
		color: white; /* Cor do texto */
		cursor: pointer;
		margin-right: 10px; /* Espaçamento à direita */
		padding: 5px; /* Espaçamento interno */
		border-radius: 3px; /* Bordas arredondadas */
		position: absolute; /* Garante o posicionamento correto */
		top: 10px; /* Posiciona na parte superior */
		right: 15px; /* Posiciona à direita */
	}

	/* Efeito de hover para qualquer botão fechar */
	.modal-content .close:hover {
		background-color: rgba(255, 0, 0, 0.2); /* Fundo vermelho claro ao passar o mouse */
		color: white; /* Mantém o texto branco */
	}

			
			
			/* Estilo geral para fontes e cor de texto */
	body {
		font-family: 'Courier New', Courier, monospace;
		color: white; /* Define o texto geral como branco */
		font-weight: bold;
	}

	/* Estilo para todas as tabelas */
	table {
		background-color: rgba(100, 0, 0, 0.8); /* Fundo vermelho ainda mais escuro e menos transparente */
		color: white; /* Define o texto das tabelas como branco */
		border: 1px solid rgba(255, 255, 255, 0.6); /* Borda branca transparente */
		font-weight: bold;
	}

	th, td {
		background-color: rgba(100, 0, 0, 0.8); /* Fundo vermelho ainda mais escuro e menos transparente */
		color: white; /* Define o texto das células como branco */
		border: 1px solid rgba(255, 255, 255, 0.6);
		padding: 8px;
		font-weight: bold;
	}

	/* Seção comum para "Vetor Tecnológico" e "Tamanho da Unidade Produtiva" */
	.config-section {
		padding: 20px;
		background-color: rgba(100, 0, 0, 0.8);
		border: 1px solid rgba(255, 255, 255, 0.6);
		border-radius: 8px;
		margin-bottom: 20px;
		display: flex; /* Usando flexbox para alinhar a seção e o globo lado a lado */
		flex-wrap: wrap; /* Permite que o conteúdo se ajuste no layout */
		justify-content: flex-start; /* Alinha os itens à esquerda */
		gap: 20px; /* Espaço entre os elementos da seção */
	}
	
	/* Seção "Tamanho da Unidade Produtiva" */
	#tamanhoUnidadeProdutivaSection {
		margin-left: 0; /* Remove a margem extra para alinhar à esquerda */
		width: 100%; /* Garantir que ocupe 100% da largura disponível */
	}

	/* Alinhamento do conteúdo */
	#tamanhoUnidadeProdutivaSection div {
		display: flex;
		align-items: center;
		justify-content: flex-start; /* Alinha à esquerda */
		gap: 10px;
	}

	#tamanhoUnidadeProdutivaSection input {
		background-color: rgba(100, 0, 0, 0.8);
		color: white;
		border: 1px solid rgba(255, 255, 255, 0.6);
		padding: 8px;
		font-family: 'Courier New', Courier, monospace;
		text-align: center;
		width: 150px; /* Define a largura do campo */
	}

	/* Títulos das seções */
	.config-section h2 {
		text-align: center;
		margin-bottom: 15px;
		font-size: 1.5em;
	}

	/* Centralização dos campos */
	.config-fields {
		flex: 1;
		display: flex;
		flex-direction: column;
		gap: 10px; /* Espaçamento entre os campos */
	}

	/* Título "Tamanho da Economia" */
	.config-section h2 {
		text-align: center; /* Centraliza o título horizontalmente */
		margin-bottom: 20px; /* Espaçamento abaixo do título */
		width: 100%; /* Título ocupa toda a largura */
	}

	/* Garantir que o globo e a seção se ajustem sem sobreposição */
	.config-content {
		display: flex;
		align-items: center; /* Alinha o globo e os campos verticalmente */
		justify-content: flex-start; /* Garante que o conteúdo da seção seja ajustado antes do globo */
		gap: 20px; /* Espaçamento entre a seção e o globo */
		width: 100%; /* Ajuste a largura para garantir que a seção ocupe toda a área */
	}

	/* Títulos em branco */
	h1, h2 {
		background-color: rgba(100, 0, 0, 0.8); /* Fundo vermelho ainda mais escuro e menos transparente */
		color: white; /* Define os títulos como brancos */
		padding: 10px;
		border-radius: 5px;
		font-weight: bold;
	}



	/* Estilo para todos os campos de entrada, botões e seletores */
	input[type="number"], input[type="text"], input[type="checkbox"], select, button {
		background-color: rgba(100, 0, 0, 0.5); /* Fundo vermelho ainda mais escuro e menos transparente */
		color: white; /* Define o texto dos campos e botões como branco */
		font-family: 'Courier New', Courier, monospace;
		padding: 5px;
		font-weight: bold;
		border: 1px solid rgba(255, 255, 255, 0.6); /* Borda semitransparente */
		padding: 5px; /* Espaçamento interno */
		border-radius: 4px; /* Borda levemente arredondada */
	}

	/* Para esconder as modais de otimização */
	#optimizationModal, #optimizationResultModal {
		display: none; /* Inicialmente escondido */
		position: fixed;
		z-index: 1050;
		left: 0;
		top: 0;
		width: 100%;
		height: 100%;
		background-color: rgba(0, 0, 0, 0.8); /* Fundo escuro semi-transparente */
		justify-content: center;
		align-items: center;
	}


	/* Estilo da imagem de boas-vindas */
	.welcome-image {
		width: 100%;
		max-width: 300px;
		margin-bottom: 15px;
	}

	#welcomeModal .modal-content {
		background-color: white; /* Fundo branco */
		color: black; /* Texto preto para contraste */
	}

		.info-bar {
		background-color: rgba(100, 0, 0, 0.8); /* Fundo vermelho transparente */
		color: white;
		font-family: 'Courier New', Courier, monospace;
		font-weight: bold;
		padding: 10px 15px;
		position: fixed;
		top: 0;
		left: 0;
		width: 100%;
		z-index: 1000;
		box-shadow: 0 8px 16px rgba(0, 0, 0, 0.6);
		display: flex;
		flex-direction: column;
		gap: 10px;
	}

	.news-ticker {
		display: flex;
		align-items: center; /* Alinha verticalmente o texto e a imagem */
		justify-content: space-between; /* Espaça o texto e o ícone */
		white-space: nowrap;
		overflow: hidden; /* Impede o conteúdo de transbordar */
		padding-right: 35px; /* Adiciona espaço à direita do contêiner */
		box-sizing: border-box; /* Garante que o padding seja incluído nas dimensões totais */
	}


	#newsMarquee {
		flex-grow: 1; /* Faz o texto ocupar o máximo de espaço disponível */
	}

	.ticker-icon {
		height: 1.5em; /* Ajusta o tamanho da imagem */
		max-width: 50px; /* Limita a largura máxima do ícone */
		margin-left: 10px; /* Espaço entre o texto e a imagem */
		margin-right: 0; /* Remove margens adicionais se necessário */
		vertical-align: middle;
	}





	/* Linha com o GIF e o texto */
	.info-row {
		display: flex;
		align-items: center; /* Alinha verticalmente o texto e o GIF */
		gap: 10px; /* Espaçamento entre o GIF e o texto */
	}

	/* Estilo do texto com localização e hora */
	#infoText {
		font-size: 18px;
	}

	/* Estilo do GIF */
	.info-gif {
		height: 2em; /* Ajuste proporcional ao tamanho do texto */
		vertical-align: middle;
	}

	/* Letreiro de notícias */
	#newsTicker {
		overflow: visible; /* Garante que nada seja cortado */
		height: auto; /* Ajusta a altura automaticamente */
		padding-top: 5px; /* Espaço extra acima do texto/imagem */
		display: flex; /* Habilita flexbox para centralização */
		align-items: flex-end;
	}

	#newsTicker img {
		height: 1.7em; /* Mesmo tamanho do texto do letreiro */
		vertical-align: middle; /* Alinha verticalmente com o texto */
		margin-right: 1px; /* Espaço entre a imagem e o texto */
		transform: translateY(-1px); /* Move a imagem 5 pixels para cima */
	}

			#successBox {
		position: fixed;
		top: -50px; /* Começa fora da tela */
		left: 50%;
		transform: translateX(-50%);
		background-color: rgba(0, 255, 0, 0.8); /* Fundo verde transparente */
		color: white;
		padding: 10px 20px;
		border-radius: 5px;
		font-size: 16px;
		font-weight: bold;
		text-align: center;
		opacity: 0; /* Transparente inicialmente */
		transition: top 0.5s ease, opacity 0.5s ease; /* Animações */
		z-index: 2000;
	}

	.welcome-ticker {
		overflow: hidden; /* Esconde o conteúdo que transborda */
		white-space: nowrap; /* Impede quebra de linha */
		box-sizing: border-box;
		width: 100%; /* Ajusta à largura do modal */
		font-size: 1.5em; /* Tamanho do texto */
		color: black; /* Cor do texto */
		background-color: rgba(255, 255, 255, 0.8); /* Fundo branco semi-transparente */
		padding: 10px; /* Espaçamento interno */
	}

	.welcome-ticker span {
		display: inline-block;
		animation: scroll-text 10s linear infinite; /* Aplica a animação */
	}

	@keyframes scroll-text {
		0% {
			transform: translateX(100%); /* Começa fora da tela, à direita */
		}
		100% {
			transform: translateX(-100%); /* Sai fora da tela, à esquerda */
		}
	}

	#globeWrapper {
    position: relative; /* Define o contexto de posição */
    width: 300px; /* Ajuste de acordo com o tamanho do globo */
    height: 300px;
    margin: 0 auto; /* Centraliza o contêiner */
}

	#globeBorder {
		position: absolute;
		top: 50%;
		left: 50%;
		width: 350px; /* Ajuste para ser um pouco maior que o globo */
		height: 350px;
		transform: translate(-50%, -50%); /* Centraliza a imagem no contêiner */
		z-index: 0; /* Garante que fique atrás do globo */
		opacity: 0.5; /* Define a transparência */
		pointer-events: none; /* Impede que a imagem interfira com cliques */
	}

	#globeContainer.logged-in {
		width: 300px;
		height: 300px;
		position: relative; /* Relativo ao contêiner pai */
		margin-left: 20px; /* Espaçamento entre a seção e o globo */
		display: flex;
		justify-content: center;
		align-items: center;
		float: right; /* Alinha o globo à direita */
		z-index: 1; /* Manter o globo no topo, sem esconder a seção */
	}

	#globeContainer {
		width: 300px;
		height: 300px;
		position: relative; /* Relativo ao contêiner pai */
		margin-left: auto; /* Centraliza horizontalmente */
		margin-right: auto; /* Centraliza horizontalmente */
		display: block; /* Garante que o contêiner se comporte como bloco */
		z-index: 1;
		visibility: hidden; /* Oculta inicialmente */
	}

#globeContainer::before {
    content: "";
    position: absolute;
    top: 60%;
    left: 50%;
    width: 350px; /* Ajuste para ser maior que o globo */
    height: 350px;
    background: url('https://i.postimg.cc/TPs1T9y9/bordalogourss-transformed-removebg-preview.png') no-repeat center center;
    background-size: contain;
    transform: translate(-50%, -50%);
    z-index: 0; /* Garante que fique atrás do globo */
    opacity: 0.5; /* Define a transparência */
    pointer-events: none; /* Evita interferência com cliques */
}

#globeContainer::after {
    content: "";
    position: absolute;
    top: 40%;
    left: 50%;
    width: 300px; /* Ajuste para o tamanho desejado da faixa */
    height: 290px;
    transform: translateX(-50%);
    background: url('https://i.postimg.cc/m2s8BxFm/faixatrabalhadoresunivos-semfundo.png') no-repeat center center;
    background-size: contain;
    z-index: 2; /* Garante que a faixa fique acima do globo e dos ramos */
	opacity: 0.9; /* Define a transparência */
    pointer-events: none; /* Evita que interfira em interações */
}


	/* Estilo geral para os campos de entrada */
	input[type="text"], input[type="password"] {
		background-color: rgba(100, 0, 0, 0.8); /* Fundo vermelho escuro translúcido */
		color: white; /* Texto branco */
		border: 1px solid rgba(255, 255, 255, 0.6); /* Borda branca translúcida */
		padding: 5px;
		font-family: 'Courier New', Courier, monospace;
		font-weight: bold;
	}

	/* Placeholder com tom de cinza mais claro */
	input[type="text"]::placeholder, input[type="password"]::placeholder {
		color: rgba(200, 200, 200, 0.7); /* Cinza claro translúcido */
		font-style: italic; /* Texto em itálico */
	}

	/* Alterações ao focar no campo */
	input[type="text"]:focus, input[type="password"]:focus {
		outline: none; /* Remove o contorno padrão */
		background-color: rgba(100, 0, 0, 0.9); /* Fundo mais opaco ao focar */
		border: 1px solid rgba(255, 255, 255, 0.8); /* Borda mais clara ao focar */
	}	
	
	#vetorTecnologicoSection {
		margin-top: 20px;
	}

	/* Aplica o efeito de hover para todas as tabelas */
	table tbody tr:hover {
		background-color: rgba(255, 150, 150, 0.5); /* Cor de destaque ao passar o mouse */
	}
		
	/* Define o cursor padrão para campos readonly */
	input[readonly] {
		cursor: default; /* Mantém o cursor como setinha */
	}
	
	.custom-tooltip {
		position: absolute;
		background-color: rgba(0, 0, 0, 0.8); /* Fundo preto semi-transparente */
		color: white; /* Texto branco */
		padding: 5px 10px; /* Espaçamento interno */
		border-radius: 4px; /* Bordas arredondadas */
		font-size: 14px; /* Tamanho do texto */
		white-space: nowrap; /* Impede quebra de linha */
		pointer-events: none; /* Evita interferência do mouse */
		box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Sombra para destaque */
		z-index: 1000; /* Garante que fique no topo */
	}

	/* Desabilita a seleção de texto globalmente */
* {
    user-select: none; /* Desativa a seleção */
}

/* Permite a seleção apenas em campos de texto */
input[type="text"], textarea {
    user-select: text; /* Permite a seleção de texto */
}

.highlight-column {
    background-color: rgba(120, 30, 30, 0.5) !important;
}

	#inputTable {
		cursor: cell; /* Exibe um cursor de cruz, similar ao Excel */
	}

#inputTable input{
	cursor: cell; /* Exibe um cursor de cruz, similar ao Excel */
    background-color: transparent !important;
    border: none !important;
    color: white !important;
    padding: 0 !important;
    font-family: inherit;
    font-size: inherit;
    box-shadow: none !important;
}

#inputTable input:focus {
    outline: none !important;
}

#inputTable input[type="text"]{
    text-align: right !important; /* Alinha o texto à direita */
	direction: rtl;    /* Inverte a direção para mostrar a parte final do texto */
}

 /* Estilo do botão e do menu */
    #languageMenu {
        position: absolute;
        background-color: rgba(100, 0, 0, 0.9); /* Fundo escuro alinhado com o estilo da página */
        color: white; /* Texto branco */
        border: 1px solid rgba(255, 255, 255, 0.6); /* Borda translúcida */
        border-radius: 5px;
        padding: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.6); /* Sombra para destaque */
        z-index: 1000;
        display: none; /* Oculto por padrão */
    }

    #languageMenu button {
        display: block;
        background: none;
        border: none;
        color: white;
        text-align: left;
        padding: 5px;
        width: 100%;
        font-size: 16px;
        cursor: pointer;
        transition: background-color 0.3s;
    }

    #languageMenu button:hover {
        background-color: rgba(255, 255, 255, 0.2); /* Destaque ao passar o mouse */
    }

    /* Estilo do botão principal */
    #languageButton {
        background-color: rgba(100, 0, 0, 0.8); /* Alinhado ao padrão da página */
        border: 1px solid rgba(255, 255, 255, 0.6);
        color: white;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        font-size: 20px;
        cursor: pointer;
        transition: filter 0.3s;
    }

    #languageButton:hover {
        filter: brightness(1.5); /* Efeito de brilho */
    }
		
	.worker-config-section {
		align-items: flex-start; /* Alinha os itens no topo */		
		padding: 20px;
		background-color: rgba(100, 0, 0, 0.8);
		border: 1px solid rgba(255, 255, 255, 0.6);
		border-radius: 8px;
		margin-bottom: 20px;
		display: flex; /* Usando flexbox para alinhar a seção e o globo lado a lado */
		flex-wrap: wrap; /* Permite que o conteúdo se ajuste no layout */
		justify-content: flex-start; /* Alinha os itens à esquerda */
		gap: 20px; /* Espaço entre os elementos da seção */
	}

	.worker-config-section > div {
		display: flex;
		flex-direction: column; /* Alinha os campos verticalmente */
		gap: 10px; /* Espaçamento entre os itens */
	}

	#uuidQRCode {
		min-width: 200px;
		min-height: 200px;
		margin: 0; /* Remove margens automáticas */
		margin-top:30px;
		border: 1px solid #ccc;
	}
			
		</style>
	</head>
	<body>
	
		<div id="welcomeModal" class="modal">
			<div class="modal-content">
				<div class="modal-title-bar">
					<img src="https://i.postimg.cc/TPhm79zs/pngwing-com-8.png" alt="Ícone de estrela">
					<span>Planificação Econômica Democrática e com Otimização</span>
					&nbsp;<img src="https://i.postimg.cc/TPhm79zs/pngwing-com-8.png" alt="Ícone de estrela">
					<button class="close" onclick="closeWelcomeModal()">&times;</button>
				</div>
				<br>
				<img src="https://s11.gifyu.com/images/Syrzl.gif" alt="Imagem de boas-vindas" class="welcome-image">
				<h2>Bem-Vindo à Ditadura do Proletariado, Companheiro!</h2>
				<div id="welcomeTicker" class="welcome-ticker">
					<span>É hora de arrumarmos a casa!</span>
				</div>
				
			</div>
		</div>

	<div id="successBox">Salvo!</div>


		<br>&nbsp <br> &nbsp <br> &nbsp <br> &nbsp <br> &nbsp <br>
		<h1>
		Planificacao Economica Teste |&nbsp;<audio id="audioContainer" src="https://cast.hoost.com.br:20064/stream" autoplay controls></audio>
		&nbsp;
		<button id="languageButton" onclick="toggleLanguageMenu(event)">🌐</button>
		<div id="languageMenu" style="display: none;">
			<button onclick="translatePage('pt')">🇧🇷 Português</button>
			<button onclick="translatePage('es')">🇦🇷 Español</button>
			<button onclick="translatePage('ru')">🇷🇺 Русский</button>
			<button onclick="translatePage('ar')">🇵🇸 العربية</button>
			<button onclick="translatePage('fr')">🇭🇹 Français</button>
			<button onclick="translatePage('en')">🇸🇩 English</button>
			<button onclick="translatePage('yo')">🇳🇬 Èdè Yorùbá</button>
			<button onclick="translatePage('zh')">🇨🇳 中文</button>
		</div>
		
		</h1>
		<div id="infoBar" class="info-bar">
			<!-- Linha com GIF e informações de localização, data e hora -->
			<div class="info-row">
				<img src="https://s11.gifyu.com/images/SyrSF.gif" alt="Foice e Martelo" class="info-gif">
				<span id="infoText"></span>
			</div>
			<!-- Letreiro com imagem -->
		<div id="newsTicker" class="news-ticker">
			<marquee id="newsMarquee" style="font-size: 16px; color: white;"></marquee>
			<img src="https://images.emojiterra.com/twitter/v13.1/512px/1f4c8.png" alt="Ícone de gráfico" class="ticker-icon">
		</div>
		</div>




	<div id="loginSection" class="config-section" style="display: none;">
		<h2>Login</h2>
		<!-- Campo Nome de Usuário -->
		<label for="username">Nome de Usuário: </label>
		<input type="text" id="username" name="username" placeholder="Digite seu nome de usuário" maxlength="55" style="width: 250px;">
		<br><br>

		<!-- Campo Senha -->
		<label for="password">Senha: </label>
		<input type="password" id="password" name="password" placeholder="Digite sua senha">
		<br><br>

		<!-- Botões Entrar e Cadastre-se -->
		<button id="loginButton" onclick="handleLogin()">Entrar</button>
		<button id="registerButton" onclick="showRegistrationFields()">Cadastre-se</button>
		<br><br>

		<div id="registrationFields" style="display: none;">
		
			<label for="nameRegistration" style="margin-left: 10px;">Nome:</label>
			<input type="text" id="nameRegistration" placeholder="Digite seu nome completo" style="width: 150px; margin-left: 5px;">
		
			<div style="display: flex; align-items: center;">
				<label for="pronoun" style="margin-right: 10px;">Pronome: </label>
				<select id="pronoun" name="pronoun">
					<option value="feminino">Feminino</option>
					<option value="masculino">Masculino</option>
					<option value="neutro">Neutro</option>
				</select>
			</div>
		
			<label for="instance">Instância: </label>
			<select id="instance" name="instance" onchange="showFields()">
				<option value="" disabled selected>Selecione...</option>
				<option value="Trabalhador">Trabalhador</option>
				<option value="Associação de Moradores">Associação de Moradores</option>
				<option value="Comitê de Bairro">Comitê de Bairro</option>
				<option value="Comitê de Fábrica">Comitê de Fábrica</option>
				<option value="Comitê do Campo">Comitê do Campo</option>
				<option value="Comitê de Rede de Distribuição">Comitê de Rede de Distribuição</option>
				<option value="Comitê de Rede de Serviço">Comitê de Rede de Serviços</option>
				<option value="Conselho Popular Distrital de Fábrica">Conselho Popular Distrital de Fábrica</option>
				<option value="Conselho Popular Distrital Urbano">Conselho Popular Distrital Urbano</option>
				<option value="Conselho Popular Distrital de Rede de Distribuição">Conselho Popular Distrital de Rede de Distribuição</option>
				<option value="Conselho Popular Distrital de Rede de Serviços">Conselho Popular Distrital de Rede de Serviços</option>
				<option value="Conselho Popular Municipal">Conselho Popular Municipal</option>
				<option value="Conselho Popular Regional Estadual">Conselho Popular Regional Estadual</option>
				<option value="Conselho Popular Estadual">Conselho Popular Estadual</option>
				<option value="Conselho Popular Regional Nacional">Conselho Popular Regional Nacional</option>
				<option value="Conselho Popular Nacional">Conselho Popular Nacional</option>
				<option value="Conselho Popular Regional Continental">Conselho Popular Regional Continental</option>
				<option value="Conselho Popular Continental">Conselho Popular Continental</option>
				<option value="Conselho Popular Intercontinental">Conselho Popular Intercontinental</option>
			</select>
			<br><br>

			<!-- Campos adicionais -->
			<div id="additionalFields" style="display: none; flex-direction: column; gap: 10px;">
			
				<label for="preposition" style="margin-right: 10px;">Preposição: </label>
				<select id="preposition" name="preposition" style="width: 80px;">
					<option value="de">de</option>
					<option value="da">da</option>
					<option value="do">do</option>
				</select>
			
				<div style="align-items: center;">
					<label for="jurisdiction" style="margin-right: 10px;">Jurisdição: </label>
					<input 
						type="text" 
						id="jurisdiction" 
						name="jurisdiction" 
						placeholder="Nome do Local, Região etc."
						style="
							color: gray; 
							font-style: italic; 
							width: 200px; 
							background-color: transparent; 
							border: 1px solid white;
							padding: 5px;
						"
						onfocus="this.style.color='white'; this.style.fontStyle='normal'; if(this.value==='Nome do Local, Região etc.')this.value='';" 
						onblur="if(this.value===''){this.style.color='gray'; this.style.fontStyle='italic'; this.value='Nome do Local, Região etc.';}"
					>
				</div>
				<div style="display: flex; align-items: center;">
					
				</div>
			</div>
			
			<br><br>
			<!-- Botão Cadastrar -->
			<button id="registerSubmitButton" onclick="handleRegister()">Cadastrar</button>
			
		</div>	
	</div>

	<br>


		</div>

	<div id="globeContainer"></div>


	<div id="logado" style="display: none;">

	<div id="conselheiroDeConselho">
		<div class="config-section">
			<h2>Tamanho da Economia</h2>
			<label for="numRows">Número de produtos:</label>
			<input type="number" id="numRows" value="3" min="1" onkeydown="handleEnter(event)">
			<label for="numCols">Número de Setores Produtivos:</label>
			<input type="number" id="numCols" value="3" min="1" onkeydown="handleEnter(event)">
			
			<button onclick="resizeTable()" class="btn">Redimensionar</button>
			<button onclick="confirmClearTable()">Limpar Tabela</button>
			<button onclick="resetEconomy()">Resetar Economia</button>

			<label><input type="checkbox" id="autoFillCheckbox" onchange="toggleAutoFill()"> Preenchimento Automático</label>
			
			<div style="margin-bottom: 10px;">
				<label for="conselhoPopularAssociadoDeConselhoPopular">Conselho Popular Associado:</label>
				<input 
					type="text" 
					id="conselhoPopularAssociadoDeConselhoPopular" 
					style="width: 300px;">
					
				<button class="btn" style="margin-left: 10px;" onclick="fetchEstimates()">Calcular Estimativas</button>
			</div>

			
		</div>

		<div class="input-section">
			<h2>Matriz Tecnológica</h2>
			<table id="inputTable">
				<thead>
					<tr>
						<th>Produtos / Setores Produtivos</th>
						<th><input type="text" value="Produção de Automóveis" readOnly></th>
						<th><input type="text" value="Produção de Computadores" readOnly></th>
						<th><input type="text" value="Produção de Celulares" readOnly></th>
					</tr>
				</thead>
				<tbody id="inputTechnologicalMatrixTableBody">
					<!-- Linhas serão preenchidas dinamicamente -->
				</tbody>
			</table>


			<h2 id="SecaoDemandaFinal">Demanda Final</h2>
	<table id="finalDemandTable">
		<thead>
			<tr>
				<th>Produto</th>
				<th>Demanda (mil)</th>
				<th>Ações</th>
			</tr>
		</thead>
		<tbody id="finalDemandInputs">
			<tr>
				<td>Automóveis</td>
				<td><input id="demand0" type="number" value="1"></td>
				<td><button onclick="openOptimizationModal(0)">Otimizar</button></td>
			</tr>
			<tr>
				<td>Computadores</td>
				<td><input id="demand1" type="number" value="0"></td>
				<td><button onclick="openOptimizationModal(1)">Otimizar</button></td>
			</tr>
			<tr>
				<td>Celulares</td>
				<td><input id="demand2" type="number" value="0"></td>
				<td><button onclick="openOptimizationModal(2)">Otimizar</button></td>
			</tr>
		</tbody>
	</table>

	<button onclick="planify()">Planificar</button>


		<!-- Modal para entrada de parâmetros de otimização -->
		<div id="optimizationModal" class="modal">
			<div class="modal-content">
				<div class="modal-title-bar">
					<img src="https://i.postimg.cc/TPhm79zs/pngwing-com-8.png" alt="Ícone de estrela">
					<span>Parâmetros de Otimização</span>
					&nbsp;<img src="https://i.postimg.cc/TPhm79zs/pngwing-com-8.png" alt="Ícone de estrela">
					<button class="close" onclick="closeOptimizationModal()">&times;</button>
				</div>
				<p><strong>Produto:</strong> <span id="productName"></span></p>
				<label for="workerLimit">Limite de Trabalhadores nas Fábricas:</label>
				<input type="number" id="workerLimit" required><br><br>
				<label for="workerHours">Carga Horária Diária (h):</label>
				<input type="number" id="workerHours" max="12" required><br><br>
				<label for="productionTime">Tempo para Produzir 1 Unidade (h):</label>
				<input type="number" id="productionTime" required><br><br>
				<label for="weeklyScale">Escala semanal (dias):</label>
				<input type="number" id="weeklyScale" min="1" max="7" required><br><br>
				<label for="nightShift">Turno Noturno:</label>
				<input type="checkbox" id="nightShift"><br><br>
				<button onclick="saveOptimizationInputs()">Salvar</button>
			</div>
		</div>



		<!-- Modal para exibir resultados de otimização -->
		<div id="optimizationResultModal" class="modal">
			<div class="modal-content">
				<div class="modal-title-bar">
					<img src="https://i.postimg.cc/TPhm79zs/pngwing-com-8.png" alt="Ícone de estrela">
					<span>Plano de Produção do Setor</span>
					&nbsp;<img src="https://i.postimg.cc/TPhm79zs/pngwing-com-8.png" alt="Ícone de estrela">
					<button class="close" onclick="closeOptimizationResultModal()">&times;</button>
				</div>
				<div id="optimizationResult"></div>
			</div>
		</div>


		<div class="output-section">
			<!-- Título "Planificação Otimizada", visível após clicar em "Planificar" -->
			<h2 id="planificationTitle" style="display: none;">Planificação Otimizada</h2>
			<div id="result"></div>
		</div>

	<!-- Botão "Dados copiáveis", visível após clicar em "Planificar" -->
	<button id="openCopyableDataModal" class="btn" style="display: none;">Dados copiáveis</button>

	<!-- Janela modal para exibir os dados copiáveis -->
	<div id="copyableDataModal" class="modal" style="display: none;">
		<div class="modal-content">
			<div class="modal-title-bar">
				<img src="https://i.postimg.cc/TPhm79zs/pngwing-com-8.png" alt="Ícone de estrela">
				<span>Dados Copiáveis</span>
				&nbsp;<img src="https://i.postimg.cc/TPhm79zs/pngwing-com-8.png" alt="Ícone de estrela">
				<button class="close" onclick="closeCopyableDataModal()">&times;</button>
			</div>

			<div class="modal-body">
				<h3>Matriz Tecnológica (para cópia)</h3>
				<pre id="matrixModalOutput" style="background-color: #333; color: white; padding: 10px; border-radius: 8px; overflow-x: auto;"></pre>
				<h3>Vetor de Demanda (para cópia)</h3>
				<pre id="vectorModalOutput" style="background-color: #333; color: white; padding: 10px; border-radius: 8px; overflow-x: auto;"></pre>
			</div>
		</div>
	</div>

		<button id="downloadDataButton" class="btn" style="display: none;">Salvar Localmente</button>
		<button id="uploadDataButton" class="btn">Upload de Arquivo</button>
		<input type="file" id="uploadInput" style="display: none;" accept=".csv" />
		<button id="sendDataButton" class="btn" onclick="sendDataToJsonBin()" style="display: none;">Salvar Online</button>
		<button id="fetchDataButton" class="btn" onclick="fetchDataFromJsonBin()">Receber Online</button>
	</div>
	</div>
	<div id="conselheiroDeComiteDeFabricaOuCampo">

	<div id="tamanhoUnidadeProdutivaSection">
		<h2>Informações da Unidade Produtiva</h2>
		<div class="config-section">
			<label for="quantidadeBensProducao" style="margin: 0;">Quantidade de Bens de Produção:</label>
			<input 
				type="number" 
				id="quantidadeBensProducao" 
				value="3" 
				min="1" 
				onkeydown="if (event.key === 'Enter') updateVetorTecnologicoTable()" 
				style="width: 100px;">
			<button onclick="updateVetorTecnologicoTable()">Redimensionar</button>
			
			 <!-- Novo campo de texto "Setor" -->
			<label for="setorUnidade" style="margin-left: 10px;">Setor:</label>
			<input 
				type="text" 
				id="setorUnidade" 
				placeholder="Digite o setor"
				style="width: 150px; margin-left: 5px;">
				
			<label for="comiteColTitle" style="margin-left: 10px;">Nome da Unidade de Produção:</label>
			<input type="text" id="comiteColTitle" placeholder="Digite o comitê" style="width: 150px; margin-left: 5px;">
			
			 <div style="margin-bottom: 10px;">
				<label for="limiteEfetivoTrabalhadores">Limite Efetivo de Trabalhadores na Unidade de Produção:</label>
				<input 
					type="number" 
					id="limiteEfetivoTrabalhadores" 
					style="width: 150px;">
			</div>

			<div style="margin-bottom: 10px;">
				<label for="conselhoPopularAssociadoDeComiteOuTrabalhador">Conselho Popular Associado:</label>
				<input 
					type="text" 
					id="conselhoPopularAssociadoDeComiteOuTrabalhador" 
					style="width: 300px;">
			</div>
			
			<div style="margin-bottom: 10px;">
				<button id="updateDemandAndGoalButton" class="btn" onclick="updateDemandAndGoal()">Atualizar Demanda e Meta</button>
			</div>
			
		</div>
	</div>

	<div id="vetorTecnologicoSection">
		<h2>Vetor Tecnológico</h2>
		<table id="vetorTecnologicoTable" class="input-section">
			<thead>
				<tr>
					<th>Bens de Produção</th>
					<th></th>
				</tr>
			</thead>
			<tbody>
				<!-- Linhas preenchidas dinamicamente -->
			</tbody>
		</table>
	</div>

	<div id="estoqueDemandaSection" class="input-section">
		<h2>Estoque e Demanda</h2>
		<table id="estoqueDemandaTable">
			<thead>
				<tr>
					<th>Bem de Produção</th>
					<th>Estoque (mil)</th>
					<th>Demanda (mil)</th>
					<th>
						<button id="propostaButton" class="btn" onclick="openPropostaModal()">Proposta</button>
					</th>
				</tr>
			</thead>
			<tbody>
				<!-- Linhas preenchidas dinamicamente -->
			</tbody>
		</table>
	</div>




	<!-- Modal "Proposta para demais Trabalhadores" -->
	<div id="propostaModal" class="modal" style="display: none;">
		<div class="modal-content">
			<div class="modal-title-bar">
				<img src="https://i.postimg.cc/TPhm79zs/pngwing-com-8.png" alt="Ícone de estrela">
				<span>Proposta para demais Trabalhadores</span>
				&nbsp;<img src="https://i.postimg.cc/TPhm79zs/pngwing-com-8.png" alt="Ícone de estrela">
				<button class="close" onclick="closePropostaModal()">&times;</button>
			</div>
			<p><strong>Nome da Unidade de Produção:</strong> <span id="unitName"></span></p>
			<label for="workerLimitProposta">Limite de Trabalhadores na Unidade de Produção:</label>
			<input type="number" id="workerLimitProposta" required><br><br>
			<label for="workerHoursProposta">Carga Horária Diária (h):</label>
			<input type="number" id="workerHoursProposta" max="12" required><br><br>
			<label for="productionTimeProposta">Tempo para Produzir 1 Unidade (h):</label>
			<input type="number" id="productionTimeProposta" required><br><br>
			<label for="weeklyScaleProposta">Escala semanal (dias):</label>
			<input type="number" id="weeklyScaleProposta" min="1" max="7" required><br><br>
			<label for="nightShiftProposta">Turno Noturno:</label>
			<input type="checkbox" id="nightShiftProposta"><br><br>
			<button onclick="savePropostaInputs()">Salvar</button>
		</div>
	</div>

	<div id="producaoMetaSection" class="input-section">
		<h2>Produção e Meta</h2>
		<table id="producaoMetaTable">
			<thead>
				<tr>
					<th>Produto</th>
					<th>Quantidade Produzida (mil)</th>
					<th>Quantidade que Falta ser Produzida (mil)</th>
					<th></th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td><input type="text" value="Produto Produzido"></td>
					<td><input id="producedQuantity" type="number" value="0"></td>
					<td><input id="pendingProductionQuantity" type="number" value="10000" readOnly></td>
					<td>
						<button class="btn" onclick="openProducaoMetaModal()">Planejamento</button>
					</td>
				</tr>
			</tbody>
		</table>
	</div>

	<!-- Modal para "Plano dessa Unidade de Produção" -->
	<div id="producaoMetaModal" class="modal" style="display: none;">
		<div class="modal-content">
			<div class="modal-title-bar">
				<img src="https://i.postimg.cc/TPhm79zs/pngwing-com-8.png" alt="Ícone de estrela">
				<span>Plano dessa Unidade de Produção</span>
				&nbsp;<img src="https://i.postimg.cc/TPhm79zs/pngwing-com-8.png" alt="Ícone de estrela">
				<button class="close" onclick="closeProducaoMetaModal()">&times;</button>
			</div>
			<div id="producaoMetaContent">
				<p><strong>Nome da Unidade de Produção:</strong> ${comiteColTitle}</p>
				<p><strong>Produto:</strong> ${productName}</p>
				<p><strong>Expediente:</strong> ${data.optimizationInputs[productIndex].workerHours} horas</p>
				<p><strong>Escala Semanal:</strong> ${data.optimizationResults[productIndex].workerHours}</p>
				<p><strong>Quantidade Necessária de Trabalhadores:</strong> ${optimizationInputs[productIndex].workerLimit}</p>
				<p><strong>Produção pendente:</strong> ${instanceData.producaoMeta}</p>
				<p><strong>Turno:</strong> ${instanceData.workShift}</p>
				<p><strong>Tempo para Produção (para contratação ou renovação):</strong> ${instanceData.totalEmploymentPeriod}</p>
			</div>
		</div>
	</div>


	</div>


	<div id="conselheiroDeAssociacaoDeMoradores"> Conselheiro de Associação de Moradores </div>

	<div id="trabalhador">
	
	Tela de Trabalhador <br/><br/>
	Trabalho Social Total: <input id="totalSocialWork" /> <br/>
	
	Participação Social no Trabalho Social (0,01% 0,001: ${percentualTrabalhoSocialDoTrabalhador}
	Lista de Produtos do Conselho Associado à sua Associação de Moradores: <br/>
	<span id="produtosParaConsumoDoTrabalhador">
	- Produto 1 (${percentualTrabalhoSocialProduto[1]}) <br/>
	- Produto 2 (${percentualTrabalhoSocialProduto[2]}) <br/>
	</span>
	
	<br/><br/>
	
	Onde<br/>
	- ${percentualTrabalhoSocialDoTrabalhador} = ${horasTrabalhadasDoTrabalhador/totalSocialWork} <br/>
	- ${percentualTrabalhoSocialProduto[1]} =  ${horaTrabalhadaPraProduzir1UnidadeDoProduto/totalSocialWork} <br/>
	<br/>
	- -${horasTrabalhadasDoTrabalhador} vir de um campo "Horas no Ponto Eletrônico: <input id="horasTrabalhadasDoTrabalhador" />".<br/>
	
	
	
	<div id="workCertificateSection">
		
		<div id="workCertificateSection">
		<h2>Certificado de Trabalho</h2>
		<div class="worker-config-section">
			<!-- QR Code --><br/>
			<div id="uuidQRCode"></div>

			<!-- Campos de entrada -->
			<div>
				<label for="name" style="margin-left: 10px;">Nome:</label>
				<input type="text" id="name" placeholder="Nome ainda não cadastrado" style="width: 150px; margin-left: 5px;" readOnly>

				<label for="conselhoPopularAssociadoDeComiteOuTrabalhadorTelaTrabalhador">
					Conselho de Distribuição e Serviço Associado:
				</label>
				<input type="text" id="conselhoPopularAssociadoDeComiteOuTrabalhadorTelaTrabalhador" style="width: 300px;">

				<label for="comiteAssociadoDeTrabalhador">Comitê de Unidade de Produção Associado:</label>
				<input type="text" id="comiteAssociadoDeTrabalhador" style="width: 300px;">

				<label for="associacaoDeMoradoresAssociadaDeTrabalhador">Associação de Moradores Associada:</label>
				<input type="text" id="associacaoDeMoradoresAssociadaDeTrabalhador" style="width: 300px;">

				<label for="hoursAtElectronicPoint">Horas no Ponto Eletrônico (h no mês):</label>
				<input type="number" id="hoursAtElectronicPoint" style="width: 150px;">

				<label for="partipacaoIndividualEstimadaNoTrabalhoSocial">
					Participação Individual no Trabalho Social (%10^11):
				</label>
				<input type="number" id="partipacaoIndividualEstimadaNoTrabalhoSocial" style="width: 150px;" readOnly>
			</div>
		</div>
	</div>
	</div>

	<div id="pedidosDeRetirada" class="input-section">
		<h2>Pedidos de Retirada</h2>
		<table id="estoqueDemandaTable">
			<thead>
				<tr>
					<th>Bem de Consumo ou Serviço</th>
					<th>Demanda (dividir por mil quando salvar e multiplicar por mil ao carregar na tela)</th>
				</tr>
			</thead>
			<tbody>
				<!-- Linhas preenchidas dinamicamente -->
			</tbody>
		</table>
	</div>
	
	
	</div>

		<script>
		
			let userIsLoggedIn = false;
			let user = null;
			let primeiroConselheiroDoConselho = true;
			// Variáveis globais para armazenar os dados antigos
			let previousTableData = [];
			let previousProductNames = [];
			let previousSectorNames = [];
			let previousDemandValues = [];
			let propostaDados = {};
			let councilData = null;
			let modalContext = null;
			let conselhoMundialKey = "Conselho Popular Intercontinental da Terra";
			let totalSocialWork = 0;
			let totalSocialWorkDessaJurisdicao = 0;
			let effectivelyPlannedProductionTime = 0;
			
		
			const productNames = [
				"Automóveis", "Computadores", "Celulares", "Geladeiras", "Televisores",
				"Roupas de algodão", "Embalagens plásticas", "Móveis de madeira", "Aço",
				"Vidro", "Produtos de limpeza", "Tintas", "Cosméticos", "Borracha",
				"Medicamentos", "Papel", "Embalagens de alumínio", "Fertilizantes",
				"Peças automotivas", "Componentes eletrônicos"
			];

			const inputNames = [
				"Aço", "Plástico", "Alumínio", "Madeira", "Vidro", "Algodão", "Borracha",
				"Produtos químicos", "Cobre", "Tinta", "Polímeros", "Petróleo", "Sílica",
				"Borracha sintética", "Lítio", "Carbonato de cálcio", "Petróleo refinado",
				"Bioetanol", "Minério de ferro", "Celulose"
			];

			const predefinedValues = [
				[0.2, 0.1, 0.05, 0.02, 0.05, 0.1, 0.02, 0.1, 0.08, 0.1, 0.02, 0.05, 0.02, 0.08, 0.05, 0.04, 0.02, 0.02, 0.05, 0.05],
				[0.05, 0.2, 0.08, 0.1, 0.03, 0.05, 0.1, 0.02, 0.07, 0.05, 0.1, 0.03, 0.05, 0.08, 0.1, 0.02, 0.04, 0.02, 0.07, 0.04],
				[0.03, 0.1, 0.2, 0.02, 0.08, 0.07, 0.02, 0.05, 0.1, 0.05, 0.04, 0.02, 0.07, 0.1, 0.02, 0.08, 0.05, 0.05, 0.02, 0.08],
				[0.08, 0.05, 0.02, 0.2, 0.05, 0.1, 0.05, 0.07, 0.02, 0.1, 0.08, 0.03, 0.02, 0.05, 0.04, 0.1, 0.05, 0.1, 0.02, 0.07],
				[0.1, 0.02, 0.05, 0.03, 0.2, 0.05, 0.1, 0.02, 0.07, 0.05, 0.1, 0.04, 0.05, 0.03, 0.1, 0.08, 0.05, 0.1, 0.07, 0.02],
				[0.05, 0.1, 0.02, 0.08, 0.03, 0.2, 0.07, 0.05, 0.1, 0.04, 0.05, 0.1, 0.02, 0.1, 0.05, 0.08, 0.05, 0.03, 0.1, 0.04],
				[0.07, 0.02, 0.05, 0.1, 0.05, 0.1, 0.2, 0.03, 0.02, 0.07, 0.08, 0.05, 0.1, 0.02, 0.05, 0.07, 0.1, 0.04, 0.08, 0.05],
				[0.02, 0.05, 0.1, 0.05, 0.07, 0.03, 0.1, 0.2, 0.08, 0.05, 0.03, 0.08, 0.02, 0.1, 0.05, 0.1, 0.07, 0.05, 0.02, 0.04],
				[0.05, 0.1, 0.02, 0.1, 0.04, 0.05, 0.07, 0.05, 0.2, 0.08, 0.1, 0.02, 0.05, 0.1, 0.05, 0.04, 0.08, 0.07, 0.02, 0.1],
				[0.1, 0.05, 0.07, 0.05, 0.08, 0.1, 0.03, 0.1, 0.05, 0.2, 0.05, 0.07, 0.04, 0.1, 0.03, 0.05, 0.1, 0.04, 0.07, 0.08],
				[0.02, 0.07, 0.05, 0.04, 0.1, 0.08, 0.05, 0.1, 0.1, 0.03, 0.2, 0.02, 0.07, 0.05, 0.1, 0.04, 0.08, 0.05, 0.1, 0.02],
				[0.05, 0.1, 0.08, 0.02, 0.04, 0.05, 0.1, 0.03, 0.1, 0.07, 0.02, 0.2, 0.08, 0.05, 0.04, 0.05, 0.1, 0.1, 0.03, 0.07],
				[0.03, 0.05, 0.1, 0.08, 0.1, 0.02, 0.07, 0.05, 0.05, 0.04, 0.1, 0.07, 0.2, 0.02, 0.05, 0.05, 0.08, 0.1, 0.04, 0.05],
				[0.1, 0.05, 0.03, 0.07, 0.05, 0.1, 0.02, 0.05, 0.1, 0.05, 0.1, 0.08, 0.04, 0.2, 0.07, 0.02, 0.05, 0.05, 0.1, 0.03],
				[0.05, 0.1, 0.02, 0.05, 0.08, 0.1, 0.07, 0.1, 0.03, 0.1, 0.05, 0.04, 0.05, 0.08, 0.2, 0.05, 0.1, 0.03, 0.07, 0.02],
				[0.04, 0.05, 0.1, 0.05, 0.02, 0.07, 0.08, 0.1, 0.05, 0.04, 0.08, 0.1, 0.03, 0.05, 0.07, 0.2, 0.1, 0.02, 0.05, 0.05],
				[0.05, 0.08, 0.02, 0.1, 0.07, 0.04, 0.05, 0.03, 0.05, 0.07, 0.1, 0.1, 0.02, 0.1, 0.04, 0.05, 0.2, 0.1, 0.07, 0.03],
				[0.03, 0.07, 0.05, 0.05, 0.1, 0.02, 0.1, 0.04, 0.08, 0.1, 0.05, 0.1, 0.02, 0.07, 0.05, 0.08, 0.03, 0.2, 0.05, 0.1],
				[0.07, 0.05, 0.04, 0.1, 0.05, 0.02, 0.08, 0.05, 0.1, 0.1, 0.03, 0.05, 0.05, 0.04, 0.1, 0.07, 0.02, 0.05, 0.2, 0.08],
				[0.05, 0.03, 0.1, 0.04, 0.07, 0.05, 0.08, 0.1, 0.02, 0.05, 0.1, 0.05, 0.07, 0.08, 0.02, 0.1, 0.03, 0.07, 0.08, 0.2]
			];
		
			let currentProductIndex = null;
			let optimizationInputs = {};  // Objeto para armazenar os dados de entrada de otimização de cada produto
			let optimizationResults = {};

			let optimizedStatus = {};  // Objeto para armazenar o status de otimização de cada produto


	// Função para preencher a tabela com valores iniciais baseados em predefinedValues
	function populateInitialTable() {
		const tbody = document.getElementById('inputTechnologicalMatrixTableBody');
		tbody.innerHTML = ''; // Limpa qualquer conteúdo existente na tabela

		const initialRows = 3;
		const initialCols = 3;

		// Atualiza o cabeçalho da tabela
		const thead = document.getElementById('inputTable').querySelector('thead tr');
		thead.innerHTML = '<th>Produtos / Setores Produtivos</th>';
		for (let colIndex = 0; colIndex < initialCols; colIndex++) {
			const sectorHeader = document.createElement('th');
			const sectorInput = document.createElement('input');
			sectorInput.type = 'text';
			sectorInput.value = `Produção de ${colIndex < initialRows ? productNames[colIndex] : "Outro"}`; 
			sectorInput.readOnly = true; // Define como apenas leitura
			addTooltipBehavior(sectorInput); // Adiciona o comportamento de tooltip
			sectorHeader.appendChild(sectorInput);
			thead.appendChild(sectorHeader);
		}

		// Atualiza as linhas da tabela
		for (let rowIndex = 0; rowIndex < initialRows; rowIndex++) {
			const row = document.createElement('tr');

			// Adicionar o campo de entrada para o nome do produto
			const productNameCell = document.createElement('td');
			const productInput = document.createElement('input');
			productInput.type = 'text';
			productInput.value = productNames[rowIndex];
			productInput.oninput = (e) => updateProductName(rowIndex, e.target.value);
			productNameCell.appendChild(productInput);
			row.appendChild(productNameCell);

			// Adicionar as células restantes
			for (let colIndex = 0; colIndex < initialCols; colIndex++) {
				const cell = document.createElement('td');
				const input = document.createElement('input');
				input.type = 'number';
				input.value = predefinedValues[rowIndex][colIndex];
				cell.appendChild(input);
				addHighlightBehavior(cell); // Adiciona o comportamento de destaque
				row.appendChild(cell);
			}

			tbody.appendChild(row);
		}
	}



	// Chama a função populateInitialTable() ao carregar a página
	window.onload = function() {
		populateInitialTable(); // Carrega a tabela inicial
		document.getElementById('welcomeModal').style.display = 'flex'; // Exibe o modal de boas-vindas
		togglePlanificationElements();  // Garante que os elementos estejam ocultos no carregamento
		
		try {
			document.getElementById('fetchDataButton').click();
		} catch (error) {
			console.error("Erro ao executar 'Receber Dados':", error);
		}
		
		showNotification("Olá! Se for Conselheiro você pode fazer login.", true);
		
		initSmallGlobe();
		
	}

	// Função para fechar o modal
	function closeWelcomeModal() {
		const modal = document.getElementById('welcomeModal');
		modal.style.display = 'none';
	}


			document.addEventListener('keydown', (event) => {
				if (event.key === 'Escape') {
					
					 closeAllModals();
					
				}
				
				if (event.ctrlKey && event.key === 'Enter') {
					event.preventDefault(); // Impede ações padrão, se houver
					planify(); // Chama a função de planificação
				}
				
				 if (event.ctrlKey) {
					// Filtra apenas as combinações específicas configuradas no programa
					if (event.key === 'd' || event.key === 'D') {
						event.preventDefault(); // Impede a ação padrão apenas para CTRL+S
						const downloadButton = document.getElementById('downloadDataButton');
						if (downloadButton) {
							downloadButton.click();
						}
					} else if (event.key === 'o' || event.key === 'O') {
						event.preventDefault(); // Impede a ação padrão apenas para CTRL+O
						const uploadButton = document.getElementById('uploadDataButton');
						if (uploadButton) {
							uploadButton.click();
						}
					} else if (event.key === 's' || event.key === 'S') {
						event.preventDefault(); // Impede o comportamento padrão do navegador (salvar página)
						
						if (userIsLoggedIn) { // Verifica se o usuário está logado
							const sendButton = document.getElementById('sendDataButton');
							if (sendButton) {
								sendButton.click(); // Simula o clique no botão "Enviar Dados"
							}
						} else {
							showNotification("Você precisa estar logado para poder salvar suas alterações", false);
						}
					} else if (event.key === 'Backspace') {
						event.preventDefault(); // Evita a ação padrão do navegador
						confirmClearTable(); // Chama a função de confirmação antes de limpar
					} else if (event.ctrlKey && (event.key === 'e' || event.key === 'E')) {
						if (userIsLoggedIn) { // Verifica se o usuário está logado
							event.preventDefault(); // Impede o comportamento padrão
							logout(); // Simula o clique no botão "Sair"
						}
						// Se o usuário não estiver logado, o comportamento padrão é mantido
					} else if (event.ctrlKey && (event.key === 'l' || event.key === 'L')) {
						event.preventDefault(); // Previne o comportamento padrão
						if (!userIsLoggedIn) { // Verifica se o usuário não está logado
							showLoginSection();
						}
					}
		
				}
			});

	function saveOptimizationInputs() {
		const workerLimit = parseFloat(document.getElementById('workerLimit').value);
		const workerHours = parseFloat(document.getElementById('workerHours').value);
		const productionTime = parseFloat(document.getElementById('productionTime').value);
		const nightShift = document.getElementById('nightShift').checked;
		const weeklyScale = parseInt(document.getElementById('weeklyScale').value);

		// Verificação dos campos obrigatórios
		if (
			isNaN(workerLimit) ||
			isNaN(workerHours) ||
			isNaN(productionTime) ||
			isNaN(weeklyScale) ||
			weeklyScale < 1 ||
			weeklyScale > 7
		) {
			showNotification("Por favor, preencha todos os campos corretamente. A escala semanal deve estar entre 1 e 7 dias.", false);
			return;
		}

		// Limitar a carga horária diária a no máximo 12 horas
		if (workerHours > 12) {
			showNotification("A carga horária diária não pode ser maior do que 12 horas.", false);
			return;
		}

		// Salva os dados no objeto de otimização
		if (!optimizationInputs[currentProductIndex]) {
			optimizationInputs[currentProductIndex] = {}; // Inicializa se não existir
		}

		optimizationInputs[currentProductIndex] = {
			workerLimit,
			workerHours,
			productionTime,
			nightShift,
			weeklyScale
		};

	// Atualiza os botões de otimização
		updateOptimizeButtonColor(currentProductIndex);
		closeOptimizationModal();	

		optimizedStatus[currentProductIndex] = true; // Marca o produto como otimizado
		updateOptimizeButtonColor(currentProductIndex); // Atualiza a cor do botão

		closeOptimizationModal(); // Fecha o modal após salvar

		// Verifica se a tabela de "Planificação Otimizada" está visível e executa a função "planify" automaticamente
		//const resultDiv = document.getElementById('result');
		//if (resultDiv && resultDiv.innerHTML.trim() !== '') {
		//	planify();
		//}
		
		
		
	}


	// Atualiza a função closeOptimizationModal para remover o ouvinte de eventos ao fechar o modal
	function closeOptimizationModal() {
		document.getElementById('optimizationModal').style.display = 'none';
		document.removeEventListener('keydown', handleEnterPress); // Remove o ouvinte ao fechar o modal
	}

	// Função para redimensionar a tabela e preservar dados antigos
	function resizeTable() {
		const numRows = parseInt(document.getElementById('numRows').value);
		const numCols = parseInt(document.getElementById('numCols').value);

		const table = document.getElementById('inputTable');
		const tbody = table.querySelector('tbody');
		const thead = table.querySelector('thead');

		// Armazenar os dados antigos antes do redimensionamento
		storePreviousTableData();
		storePreviousDemandValues();

		// Atualiza o cabeçalho da tabela com os nomes dos setores produtivos
		thead.innerHTML = '<tr><th>Produtos / Setor Produtivo</th></tr>';
		for (let j = 0; j < numCols; j++) {
			const sectorHeader = document.createElement('th');
			const sectorInput = document.createElement('input');
			sectorInput.type = 'text';
			sectorInput.value = previousSectorNames[j] || `Produção de ${inputNames[j % inputNames.length]}`;
			sectorInput.readOnly = true;
			addTooltipBehavior(sectorInput); // Adiciona o comportamento de tooltip
			sectorHeader.appendChild(sectorInput);
			thead.querySelector('tr').appendChild(sectorHeader);
		}

		// Redimensiona o corpo da tabela preservando os dados antigos
		tbody.innerHTML = '';
		for (let i = 0; i < numRows; i++) {
			const row = document.createElement('tr');

			// Nome do produto
			const productNameCell = document.createElement('td');
			const productInput = document.createElement('input');
			productInput.type = 'text';
			productInput.value = previousProductNames[i] || `Produto ${i + 1}`;
			//productInput.onchange = () => syncProductName(i, productInput.value);  // Sincroniza nome de produto
			productInput.oninput = () => updateProductName(i, productInput.value);
			productNameCell.appendChild(productInput);
			row.appendChild(productNameCell);

			for (let j = 0; j < numCols; j++) {
				const cell = document.createElement('td');
				const input = document.createElement('input');
				input.type = 'number';

				// Preenche com o valor antigo ou usa um valor padrão
				input.value = (previousTableData[i] && previousTableData[i][j] !== undefined)
					? previousTableData[i][j]
					: predefinedValues[i % predefinedValues.length][j % predefinedValues[0].length];

				input.onchange = storePreviousTableData;
				cell.appendChild(input);
				addHighlightBehavior(cell); // Adiciona o comportamento de destaque
				row.appendChild(cell);
			}

			tbody.appendChild(row);
		}

		// Atualiza a seção de demanda final com os nomes dos produtos e valores de demanda preservados
		updateFinalDemand(numRows);

		// Se preenchimento automático estiver habilitado, preenche automaticamente novos campos
		if (document.getElementById('autoFillCheckbox').checked) {
			autoFillTable();
		}

		// Atualiza os dados antigos
		storePreviousTableData();
	}



	// Função para armazenar os dados antigos da tabela, incluindo nomes dos produtos e setores
	function storePreviousTableData() {
		const tbody = document.getElementById('inputTable').querySelector('tbody');
		const thead = document.getElementById('inputTable').querySelector('thead');

		previousTableData = [];
		previousProductNames = [];
		previousSectorNames = [];
		previousDemandValues = []; // Armazenar os valores de demanda

		// Armazena os nomes dos setores
		const sectorHeaders = thead.querySelectorAll('th input');
		sectorHeaders.forEach((input, index) => {
			//if (index > 0) previousSectorNames[index - 1] = input.value;
			if (index >= 0) previousSectorNames[index] = input.value;
		});

		// Armazena os dados da tabela e os nomes dos produtos
		tbody.querySelectorAll('tr').forEach((row, index) => {
			const rowData = [];
			const productInput = row.querySelector('td:first-child input');
			previousProductNames[index] = productInput.value;

			row.querySelectorAll('td:not(:first-child) input').forEach((input) => {
				rowData.push(input.value || 0);
			});
			previousTableData.push(rowData);
		});

		// Armazena os valores de demanda atuais
		const demandInputs = document.querySelectorAll('#finalDemandInputs input[type="number"]');
		demandInputs.forEach(input => previousDemandValues.push(input.value || 0));
	}

	// Função para armazenar os valores antigos da demanda final
	function storePreviousDemandValues() {
		const demandInputs = document.querySelectorAll('#finalDemandInputs input[type="number"]');
		previousDemandValues = Array.from(demandInputs).map(input => input.value || 0);
	}

	// Função para atualizar a tabela de demanda final
	function updateFinalDemand(numRows) {
		const demandContainer = document.getElementById('finalDemandInputs');
		demandContainer.innerHTML = '';

		for (let i = 0; i < numRows; i++) {
			const demandRow = document.createElement('tr');

			// Nome do produto sincronizado com a tabela
			const productNameCell = document.createElement('td');
			productNameCell.textContent = previousProductNames[i] || `Produto ${i + 1}`;
			demandRow.appendChild(productNameCell);

			// Entrada de demanda (preserva valor existente ou padrão)
			const demandInputCell = document.createElement('td');
			const demandInput = document.createElement('input');
			demandInput.type = 'number';
			demandInput.id = `demand${i}`;
			demandInput.value = previousDemandValues[i] || (i === 0 ? 1 : 0);
			demandInputCell.appendChild(demandInput);
			demandRow.appendChild(demandInputCell);

			// Botão de otimização
			const buttonCell = document.createElement('td');
			const button = document.createElement('button');
			button.textContent = 'Otimizar';
			button.onclick = () => openOptimizationModal(i);
			buttonCell.appendChild(button);
			demandRow.appendChild(buttonCell);

			demandContainer.appendChild(demandRow);

			// Atualizar a cor do botão com base no status de otimização
			updateOptimizeButtonColor(i);
		}
	}

	// Função para atualizar a tabela de demanda final
	function updateFinalDemand(numRows) {
		const demandContainer = document.getElementById('finalDemandInputs');
		demandContainer.innerHTML = '';

		for (let i = 0; i < numRows; i++) {
			const demandRow = document.createElement('tr');

			// Nome do produto sincronizado com a tabela
			const productNameCell = document.createElement('td');
			productNameCell.textContent = previousProductNames[i] || `Produto ${i + 1}`;
			demandRow.appendChild(productNameCell);

			// Entrada de demanda (preserva valor existente ou padrão)
			const demandInputCell = document.createElement('td');
			const demandInput = document.createElement('input');
			demandInput.type = 'number';
			demandInput.id = `demand${i}`;
			demandInput.value = previousDemandValues[i] !== undefined ? previousDemandValues[i] : (i === 0 ? 1 : 0);
			demandInputCell.appendChild(demandInput);
			demandRow.appendChild(demandInputCell);

			// Botão de otimização
			const buttonCell = document.createElement('td');
			const button = document.createElement('button');
			button.textContent = 'Otimizar';
			button.onclick = () => openOptimizationModal(i);
			buttonCell.appendChild(button);
			demandRow.appendChild(buttonCell);

			demandContainer.appendChild(demandRow);

			// Atualizar a cor do botão com base no status de otimização
			updateOptimizeButtonColor(i);
		}
	}

	// Função para atualizar os dados antigos da tabela
	function updatePreviousTableData() {
		const tbody = document.getElementById('inputTable').querySelector('tbody');
		previousTableData = [];
		tbody.querySelectorAll('tr').forEach((row) => {
			const rowData = [];
			row.querySelectorAll('input[type="number"]').forEach((input) => {
				rowData.push(input.value || 0);
			});
			previousTableData.push(rowData);
		});
	}



	function performOptimization(productIndex) {
		const inputs = optimizationInputs[productIndex];
		if (!inputs) return;

		const { productionGoal, workerLimit, workerHours, productionTime, weeklyScale, nightShift } = inputs;

		if (!workerLimit || workerLimit <= 0) {
			const productName = getProductNames()[productIndex];
			//showNotification(`O limite de trabalhadores por fábrica não foi configurado corretamente para a produção de ${productName}.`);
			return;
		}

		// Cálculo total de horas necessárias para produzir a quantidade desejada
		const totalHours = productionTime * productionGoal;

		// Capacidade semanal por trabalhador (em horas)
		const weeklyWorkHoursPerWorker = weeklyScale * workerHours;

		// Cálculo do número de trabalhadores necessários
		const workersNeeded = Math.ceil(totalHours / weeklyWorkHoursPerWorker);

		// Capacidade total de trabalho por turno (independente de ser diurno ou noturno)
		const shiftWorkHours = workerLimit * workerHours;

		// Total de turnos necessários
		const totalShifts = Math.ceil(totalHours / shiftWorkHours);

		// Capacidade diária considerando escala semanal e turno noturno
		const dailyWorkHours = nightShift ? shiftWorkHours * 2 : shiftWorkHours;
		const totalDailyWorkHours = dailyWorkHours * weeklyScale / 7;

		// Prazo mínimo de produção em dias
		const minimumProductionTime = Math.ceil(totalHours / totalDailyWorkHours);

		// Período total de trabalho (em semanas e dias restantes)
		const totalWorkDays = Math.ceil(totalHours / dailyWorkHours);
		const totalWeeks = Math.floor(totalWorkDays / weeklyScale);
		const remainingDays = totalWorkDays % weeklyScale;

		// Cálculo das horas de operação por dia
		const factoryOperationHours = nightShift ? 24 : 12;

		// Conversão do prazo mínimo de produção para dias
		const minimumProductionTimeInDays = minimumProductionTime / 24; // Considera 1 dia = 24 horas

		// Nova fórmula para calcular o número de fábricas necessárias
		const factoriesNeeded = Math.ceil(totalHours / (factoryOperationHours * workerLimit * minimumProductionTimeInDays));



		// Cálculo da quantidade de fábricas
		//const factoriesNeeded = Math.ceil(totalHours / shiftWorkHours);

		// Formatação do período total de emprego
		let totalEmploymentPeriod;
		if (totalWorkDays < weeklyScale) {
			totalEmploymentPeriod = `${totalWorkDays} dias`;
		} else {
			totalEmploymentPeriod = formatDays(totalWorkDays * 24); // Converte dias em horas para formatDays
		}

		const table = document.querySelector('#result table'); // Seleciona a tabela "Planificação Otimizada"
		const row = table?.rows[productIndex + 1]; // Seleciona a linha correspondente ao índice (ajusta para ignorar cabeçalho)
		const plannedFinalDemand = row ? parseFloat(row.cells[1].textContent.trim())*1000 : 0; // Acessa a célula da coluna correspondente e converte o valor

		// Armazenamento dos resultados para exibição
		optimizationResults[productIndex] = {
			totalHours,
			workersNeeded,
			factoriesNeeded, // Adiciona o cálculo das fábricas
			totalShifts,
			minimumProductionTime,
			totalEmploymentPeriod,
			weeklyScale,
			plannedFinalDemand
		};
	}

	let isPlanified = false; // Variável para controlar se a planificação foi feita

	function planify() {
		const resultDiv = document.getElementById('result');
		resultDiv.innerHTML = "";

		try {
			const techMatrix = makeSquareMatrix(getTableData());
			const adjustedDemand = adjustDemandVector(getFinalDemand(), techMatrix.length);
			const identityMatrix = math.identity(techMatrix.length)._data;
			const iMinusA = math.subtract(identityMatrix, techMatrix);
			const inverseIMinusA = math.inv(iMinusA);
			const productionVector = math.multiply(inverseIMinusA, adjustedDemand);

			const productNames = getProductNames();
			resultDiv.innerHTML = `
				<table>
					<thead>
						<tr>
							<th>Produto</th>
							<th>Produção Necessária para Atender a Demanda Final (mil)</th>
							<th>Ações</th>
						</tr>
					</thead>
					<tbody>
						${productionVector.map((val, i) => {
							const hasOptimization = isOptimizationDataComplete(i); // Validação aqui
							return `
								<tr>
									<td>${productNames[i]}</td>
									<td>${val.toFixed(2)}</td>
									<td>
										${hasOptimization ? 
										`<button onclick="openOptimizationResultModal(${i})">Otimização</button>` : 
										`<button disabled>Otimização Não Disponível</button>`}
									</td>
								</tr>
							`;
						}).join('')}
					</tbody>
				</table>
			`;

			// Define a meta de produção e executa a otimização para cada produto com dados completos
			productionVector.forEach((value, index) => {
				if (isOptimizationDataComplete(index)) {
					optimizationInputs[index].productionGoal = value * 1000; // Define a meta
					performOptimization(index); // Executa a otimização
					updateOptimizeButtonColor(index); // Atualiza o botão após a otimização
				}
			});

			// Formatação da matriz e vetor para exibição
			const formattedMatrix = JSON.stringify(techMatrix, null, 2);
			const formattedVector = JSON.stringify(adjustedDemand, null, 2);

			// Preenche os elementos na modal
			document.getElementById('matrixModalOutput').textContent = formattedMatrix;
			document.getElementById('vectorModalOutput').textContent = formattedVector;

			// Marca que a planificação foi feita e exibe o título e o botão
			isPlanified = true;
			togglePlanificationElements();

			// Rolagem suave para o título "Planificação Otimizada"
			const planificationTitle = document.getElementById('planificationTitle'); // Seleciona o título "Planificação Otimizada"
			const infobar = document.getElementById('infoBar'); // Seleciona a infobar

			if (planificationTitle) {
				const infobarHeight = infobar ? infobar.offsetHeight : 0; // Calcula a altura da infobar
				const planificationTitlePosition = planificationTitle.getBoundingClientRect().top + window.scrollY; // Posição do título na página
				const targetPosition = planificationTitlePosition - infobarHeight; // Compensa a altura da infobar

				// Rola suavemente para a posição ajustada
				window.scrollTo({
					top: targetPosition,
					behavior: 'smooth',
				});
			}


		} catch (error) {
			resultDiv.innerHTML = `<p class="error-message">Erro: ${error.message}</p>`;
		}
	}


	function togglePlanificationElements() {
		const planificationTitle = document.getElementById('planificationTitle');
		const copyableButton = document.getElementById('openCopyableDataModal');
		const downloadButton = document.getElementById('downloadDataButton');

		if (isPlanified) {
			planificationTitle.style.display = 'block';  // Exibe o título
			copyableButton.style.display = 'block';      // Exibe o botão "Dados copiáveis"
			downloadButton.style.display = 'block';      // Exibe o botão "Baixar Dados"
		} else {
			planificationTitle.style.display = 'none';   // Oculta o título
			copyableButton.style.display = 'none';       // Oculta o botão "Dados copiáveis"
			downloadButton.style.display = 'none';       // Oculta o botão "Baixar Dados"
		}
	}


	// Função para fechar modais ao clicar fora do conteúdo
	function closeCopyableDataModal() {
		const modal = document.getElementById('copyableDataModal');
		modal.style.display = 'none'; // Fecha a modal
	}

	// Função para fechar a modal de otimização
	function closeOptimizationModal() {
		document.getElementById('optimizationModal').style.display = 'none';
	}

	// Exibe os resultados da otimização no modal de resultados
		function openOptimizationResultModal(index) {
		const result = optimizationResults[index];
		const inputs = optimizationInputs[index];
		if (!result || !inputs) return;

		const productName = getProductNames()[index];
		const workerHours = inputs.workerHours; // Carga horária diária configurada
		const totalHours = result.totalHours; // Total de horas de trabalho
		const workersNeeded = result.workersNeeded; // Trabalhadores necessários
		const totalShifts = result.totalShifts; // Total de turnos de trabalho
		const minimumProductionTime = result.minimumProductionTime; // Prazo mínimo de produção
		const totalEmploymentPeriod = result.totalEmploymentPeriod; // Período total em que estarão empregados
		const workShift = inputs.nightShift ? "Diurno e Noturno" : "Diurno"; // Verifica o tipo de turno
		const weeklyScale = result.weeklyScale; // Escala semanal
		const factoriesNeeded = result.factoriesNeeded;

		const daysOff = 7 - weeklyScale; // Dias de folga na semana
		const formattedWeeklyScale = `${weeklyScale}X${daysOff}`; // Formata como solicitado

		document.getElementById('optimizationResult').innerHTML = `
			<p><strong>Produto:</strong> ${productName}</p>
			<p><strong>Carga Horária Total:</strong> ${totalHours.toFixed(2)} horas</p>
			<p><strong>Fábricas Necessárias:</strong> ${factoriesNeeded}</p>
			<p><strong>Prazo Mínimo de Produção:</strong> ${formatDays(minimumProductionTime * 24)}</p>
			<p><strong>Turno:</strong> ${workShift}</p>
			<p><strong>Trabalhadores Necessários:</strong> ${workersNeeded}</p>
			<p><strong>Total de Turnos:</strong> ${totalShifts}</p>
			<p><strong>Expediente do Trabalhador:</strong> ${workerHours}h por dia</p>
			<p><strong>Escala de Trabalho:</strong> ${formattedWeeklyScale}</p>
			<p><strong>Período Total de Emprego:</strong> ${totalEmploymentPeriod}</p>
		`;


		const modal = document.getElementById('optimizationResultModal');
		modal.style.display = 'flex';
	}

	// Função para fechar a modal de resultados de otimização
	function closeOptimizationResultModal() {
		document.getElementById('optimizationResultModal').style.display = 'none';
	}

			function closeOptimizationModal() {
				document.getElementById('optimizationModal').style.display = 'none';
			}

			

			function updateOptimizeButtonColor(productIndex) {
				const button = document.querySelector(`#finalDemandInputs tr:nth-child(${productIndex + 1}) button`);
				const inputs = optimizationInputs[productIndex];

				// Verifica se todos os campos obrigatórios estão preenchidos
				const isComplete = inputs && 
					inputs.workerLimit > 0 && 
					inputs.workerHours > 0 &&
					inputs.productionTime > 0 &&
					inputs.weeklyScale > 0;

				if (isComplete) {
					button.style.backgroundColor = 'green'; // Dados completos, botão fica verde
				} else {
					button.style.backgroundColor = '';     // Reseta a cor do botão
				}
			}

		   function openOptimizationModal(productIndex) {
			   
		currentProductIndex = productIndex;

		// Inicializa os dados de otimização para o produto, se necessário
		if (!optimizationInputs[productIndex]) {
			optimizationInputs[productIndex] = {};
		}
		const inputs = optimizationInputs[productIndex] || {}; // Obtém ou inicializa os dados

		// Define o nome do produto no modal
		const productNames = getProductNames();
		document.getElementById('productName').textContent = productNames[productIndex];

		// Preenche os campos do modal com valores salvos ou padrão
		document.getElementById('workerLimit').value = inputs.workerLimit || '';
		document.getElementById('workerHours').value = inputs.workerHours || '';
		document.getElementById('productionTime').value = inputs.productionTime || '';
		document.getElementById('nightShift').checked = inputs.nightShift || false;
		document.getElementById('weeklyScale').value = inputs.weeklyScale || '';

		// Exibe o modal de otimização
		const modal = document.getElementById('optimizationModal');
		modal.style.display = 'flex';

		// Posiciona o cursor automaticamente no campo "Limite de Trabalhadores nas Fábricas"
		document.getElementById('workerLimit').focus();

		// Adiciona o ouvinte de eventos para capturar Enter
		document.addEventListener('keydown', handleEnterPress);
	}






	// Função para acionar "Salvar" ao pressionar Enter
	function handleEnterPress(event) {
		if (event.key === 'Enter') {
			event.preventDefault(); // Impede o comportamento padrão do Enter
			saveOptimizationInputs();
			document.removeEventListener('keydown', handleEnterPress); // Remove o ouvinte após salvar
		}
	}


	function handleEnter(event) {
		if (event.key === "Enter") {
			event.preventDefault(); // Impede o comportamento padrão do Enter
			resizeTable(); // Chama a função para redimensionar a tabela
		}
	}


			function closeOptimizationModal() {
				const modal = document.getElementById('optimizationModal');
				modal.style.display = 'none';
				document.removeEventListener('keydown', handleEnterPress); // Remove o ouvinte ao fechar
			}



			function toggleAutoFill() {
				if (document.getElementById('autoFillCheckbox').checked) {
					autoFillTable();
				} else {
					clearTable();
				}
			}

			function autoFillTable() {
				const rows = document.getElementById('inputTable').querySelectorAll('tbody tr');
				const productNames = ["Automóveis", "Computadores", "Celulares", "Geladeiras", "Televisores"];

				rows.forEach((row, i) => {
					row.cells[0].querySelector('input[type="text"]').value = productNames[i % productNames.length];
					let rowValues = [];
					let sum = 0;

					for (let j = 1; j < row.cells.length; j++) {
						let value = i === j ? (Math.random() * 0.05).toFixed(2) : (Math.random() * 0.1).toFixed(2);
						rowValues.push(parseFloat(value));
						sum += parseFloat(value);
					}

					if (sum >= 1) {
						rowValues = rowValues.map(value => (value / sum * 0.9).toFixed(2));
					}

					rowValues.forEach((value, j) => {
						row.cells[j + 1].querySelector('input[type="number"]').value = value;
					});
				});
			}

			function getTableData() {
				const tbody = document.querySelector('#inputTable tbody');
				const rows = tbody.querySelectorAll('tr');

				return Array.from(rows).map(row => {
					const cells = row.querySelectorAll('td:not(:first-child) input[type="number"]');
					return Array.from(cells).map(input => parseFloat(input.value) || 0);
				});
			}
			

			function getProductNames() {
				const rows = document.querySelectorAll('#inputTable tbody tr');
				return Array.from(rows).map(row => row.querySelector('td:first-child input').value);
			}

			function setProductNames(productNames) {
				const rows = document.querySelectorAll('#inputTable tbody tr');
				rows.forEach((row, index) => {
					const input = row.querySelector('td:first-child input');
					if (input && productNames[index]) {
						input.value = productNames[index];
					}
				});
			}

			function setSectorNames(sectorNames) {
				const headers = document.querySelectorAll('#inputTable thead tr th');
				headers.forEach((header, index) => {
					if (index > 0 && sectorNames[index - 1]) { // Pula a primeira coluna ("Produtos")
						const input = header.querySelector('input');
						if (input) {
							input.value = sectorNames[index - 1]; // Define o título correto do setor
						}
					}
				});
			}
			
			function getSectorNames() {
				const headers = document.querySelectorAll('#inputTable thead tr th');
				return Array.from(headers)
					.slice(1) // Ignora a primeira coluna (nomes dos produtos)
					.map(header => {
						const input = header.querySelector('input');
						return input ? input.value : `Setor ${Array.from(headers).indexOf(header)}`;
					});
			}


			function getFinalDemand() {
				const tbody = document.querySelector('#finalDemandInputs');
				const inputs = tbody.querySelectorAll('input[type="number"]');
				return Array.from(inputs).map(input => parseFloat(input.value) || 0);
			}


			function makeSquareMatrix(matrix) {
				const size = Math.max(matrix.length, matrix[0].length);
				return Array.from({ length: size }, (_, i) =>
					Array.from({ length: size }, (_, j) => (matrix[i] && matrix[i][j]) || 0)
				);
			}

			function adjustDemandVector(demand, size) {
				return Array.from({ length: size }, (_, i) => demand[i] || 0);
			}

	function resetEconomy() {
		const confirmation = confirm("Tem certeza de que deseja resetar a economia? Todos os dados serão perdidos e a economia será restaurada para o estado inicial.");
		if (confirmation) {
			location.reload(); // Recarrega a página, restaurando todos os dados ao estado inicial
		}
	}



	function confirmClearTable() {
		const confirmation = confirm("Tem certeza de que deseja limpar a tabela? Todos os dados serão perdidos.");
		if (confirmation) {
			clearTable(); // Chama a função de limpeza se confirmado
		}
	}


	function clearTable() {
		const rows = document.getElementById('inputTable').querySelectorAll('tbody tr');
		rows.forEach(row => {
			const cells = row.querySelectorAll('input[type="number"]');
			cells.forEach(cell => cell.value = '0');
		});

		// Limpa os valores de demanda e status de otimização
		const demandInputs = document.querySelectorAll('#finalDemandInputs input[type="number"]');
		demandInputs.forEach(input => input.value = '0');
		optimizedStatus = {};  // Resetar o status de otimização

		// Atualiza os botões "Otimizar" para o estado padrão
		const optimizeButtons = document.querySelectorAll('#finalDemandInputs button');
		optimizeButtons.forEach(button => button.style.backgroundColor = '');

		// Limpa os valores nas janelas modais de otimização
		if (document.getElementById('productionGoal')) {
			document.getElementById('productionGoal').value = '';
		}
		document.getElementById('workerLimit').value = '';
		document.getElementById('workerHours').value = '';
		document.getElementById('productionTime').value = '';

		// Limpa os dados de otimização armazenados para cada produto
		optimizationInputs = {};
		optimizationResults = {};

		// Limpa os resultados de "Planificar"
		document.getElementById('result').innerHTML = '';

		// Oculta o título "Planificação Otimizada" e a tabela
		isPlanified = false; // Marca que a planificação foi resetada
		togglePlanificationElements(); // Atualiza visibilidade

		// Limpa campos adicionais conforme solicitado
		document.getElementById('conselhoPopularAssociadoDeConselhoPopular').value = '';
		document.getElementById('quantidadeBensProducao').value = '';
		document.getElementById('setorUnidade').value = '';
		document.getElementById('comiteColTitle').value = '';
		document.getElementById('limiteEfetivoTrabalhadores').value = '';
		document.getElementById('conselhoPopularAssociadoDeComiteOuTrabalhador').value = '';
		document.getElementById('conselhoPopularAssociadoDeComiteOuTrabalhadorTelaTrabalhador').value = '';
		

		// Limpa todos os campos das colunas "Bens de Produção" e "Quantidade necessária para produzir 1 unidade"
		const vetorTecnologicoInputs = document.querySelectorAll('#vetorTecnologicoTable tbody input');
		vetorTecnologicoInputs.forEach(input => input.value = '');

		// Limpa todos os valores das colunas "Bem de Produção", "Estoque" e "Demanda"
		const estoqueDemandaInputs = document.querySelectorAll('#estoqueDemandaTable tbody input');
		estoqueDemandaInputs.forEach(input => input.value = '');

		// Limpa todos os valores da janela modal "Proposta para demais Trabalhadores"
		document.getElementById('workerLimitProposta').value = '';
		document.getElementById('workerHoursProposta').value = '';
		document.getElementById('productionTimeProposta').value = '';
		document.getElementById('nightShiftProposta').checked = false;
		document.getElementById('weeklyScaleProposta').value = '';

		// Limpa os campos das colunas "Produto", "Quantidade Produzida" e "Quantidade que Falta ser Produzida"
		const producaoMetaInputs = document.querySelectorAll('#producaoMetaTable tbody input');
		producaoMetaInputs.forEach(input => input.value = '');

		// Adicionalmente, limpa as variáveis associadas na memória
		previousTableData = [];
		previousProductNames = [];
		previousSectorNames = [];
		previousDemandValues = [];
		propostaDados = {};
		totalSocialWorkDessaJurisdicao = 0;
		councilData = null;
		currentProductIndex = null;
		modalContext = null;
		
		//Limpeza de variáveis e campos da tela de Trabalhador
		document.getElementById('name').value = '';
		document.getElementById('comiteAssociadoDeTrabalhador').value = '';
		document.getElementById('associacaoDeMoradoresAssociadaDeTrabalhador').value = '';
		document.getElementById('hoursAtElectronicPoint').value = '';
		document.getElementById('partipacaoIndividualEstimadaNoTrabalhoSocial').value = '';
		
	}



	function formatDays(totalHours) {
		const days = Math.floor(totalHours / 24);
		const remainingHours = totalHours % 24; // Calcula as horas restantes que não completam um dia

		const years = Math.floor(days / 365);
		const remainingDaysAfterYears = days % 365;
		const months = Math.floor(remainingDaysAfterYears / 30);
		const remainingDaysAfterMonths = remainingDaysAfterYears % 30;
		const weeks = Math.floor(remainingDaysAfterMonths / 7);
		const remainingDays = remainingDaysAfterMonths % 7;

		const pluralize = (value, singular, plural) => value === 1 ? singular : plural;

		const parts = []; // Lista para armazenar as partes não nulas

		if (years > 0) parts.push(`${years} ${pluralize(years, "ano", "anos")}`);
		if (months > 0) parts.push(`${months} ${pluralize(months, "mês", "meses")}`);
		if (weeks > 0) parts.push(`${weeks} ${pluralize(weeks, "semana", "semanas")}`);
		if (remainingDays > 0) parts.push(`${remainingDays} ${pluralize(remainingDays, "dia", "dias")}`);
		if (remainingHours > 0) parts.push(`${remainingHours} ${pluralize(remainingHours, "hora", "horas")}`);

		return parts.join(", ");
	}


	let userLocation = null; // Variável para armazenar a localização do usuário
	let userCity = "Localização não disponível"; // Cidade padrão para fallback

	// Função para atualizar o conteúdo da barra com hora e localização
	function fetchLocationAndUpdateInfoBar() {
		const infoText = document.getElementById('infoText');
		const now = new Date();
		const locale = 'pt-BR';

		// Formatar a data e hora
		const dia = now.getDate();
		const mes = now.toLocaleString(locale, { month: 'long' });
		const ano = now.getFullYear();
		const horas = now.getHours().toString().padStart(2, '0');
		const minutos = now.getMinutes().toString().padStart(2, '0');
		const segundos = now.getSeconds().toString().padStart(2, '0');

		 // Determinar o título com base no pronome
		let title = '';

		// Atualizar a barra com os dados do conselho e hora local
		if (userIsLoggedIn) {
		
			const username = document.getElementById('username').value;
			const password = document.getElementById('password').value;
			if(null == user){
				user = users.find(u => u.username === username && u.password === password);
			}
		
			if (user.instancePrepositionJurisdictionUUID.includes("WorkerUUID")) {
				//É trabalhador que não é conselheiro
				
				if (user.pronoun === 'feminino') {
					title = 'Trabalhadora';
				} else if (user.pronoun === 'masculino') {
					title = 'Trabalhador';
				} else {
					title = 'Trabalhadore';
				}				
				
				infoText.innerHTML = `${title} ${user.name}, ${dia} de ${mes} de ${ano}, ${horas}:${minutos}:${segundos} <button id="logoutButton" onclick="logout()">Sair</button>`;
			}
			else {
				//É conselheiro
				
				if (user.pronoun === 'feminino') {
					title = 'Conselheira';
				} else if (user.pronoun === 'masculino') {
					title = 'Conselheiro';
				} else {
					title = 'Conselheire';
				}
				
				infoText.innerHTML = `${title} ${user.name}, ${user.instance} ${user.preposition} ${user.jurisdiction}, ${dia} de ${mes} de ${ano}, ${horas}:${minutos}:${segundos} <button id="logoutButton" onclick="logout()">Sair</button>`;
			}
		} else {
			// Caso não tenha dados completos, mostrar apenas o texto com a hora e localização
			infoText.innerHTML = `<button id="loginButton" onclick="showLoginSection()">Faça Login</button> ${dia} de ${mes} de ${ano}, ${horas}:${minutos}:${segundos}`;
		}
	}


	// Função para obter a localização apenas uma vez
	function getUserLocation() {
		if (!navigator.geolocation) {
			// Caso o navegador não suporte geolocalização
			userCity = "Geolocalização não suportada";
			return;
		}

		// Solicitar localização do navegador apenas uma vez
		navigator.geolocation.getCurrentPosition(
			(position) => {
				const { latitude, longitude } = position.coords;

				// Obter cidade com geocodificação reversa
				fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}`)
					.then(response => response.json())
					.then(data => {
						userCity = data.address.city || data.address.town || data.address.village || "Localização desconhecida";
					})
					.catch(() => {
						userCity = "Localização não disponível";
					});
			},
			() => {
				// Caso o usuário negue a permissão
				userCity = "Permissão negada";
			}
		);
	}

	// Inicializa a localização (chamada única)
	getUserLocation();

	// Atualiza a barra continuamente para exibir a hora atualizada
	function updateInfoBar() {
		fetchLocationAndUpdateInfoBar();
	}

	// Inicializa a barra e atualiza a hora
	setInterval(updateInfoBar, 1000);
	updateInfoBar();


	// Funções para abrir e fechar a modal
	function openCopyableDataModal() {
		document.getElementById('copyableDataModal').style.display = 'flex'; // Exibe a modal
	}

	function closeCopyableDataModal() {
		document.getElementById('copyableDataModal').style.display = 'none'; // Fecha a modal
	}

	// Evento no botão para abrir a modal
	document.getElementById('openCopyableDataModal').addEventListener('click', openCopyableDataModal);

	// Função para embaralhar a lista de notícias
	function shuffleArray(array) {
		for (let i = array.length - 1; i > 0; i--) {
			const j = Math.floor(Math.random() * (i + 1));
			[array[i], array[j]] = [array[j], array[i]];
		}
		return array;
	}


	function fetchNewsTitles() {
		// Dados estáticos simulando as notícias retornadas pela API
		const headlines = [
		"Vale do São Francisco (BA/PE): Produção de 963 mil toneladas de manga e 207,7 mil toneladas de uva de mesa.",
		"Chapada do Apodi (RN): Exportação de quase metade do melão nacional e 12% da melancia.",
		"Região Sul (PR, SC, RS): 96% da produção de uva industrial do Brasil, com destaque para vinhos e espumantes.",
		"Pará (Norte): Produção de 1,5 milhão de toneladas de açaí, representando 94% do total nacional.",
		"Centro-Oeste: Crescimento no cultivo de frutas nativas como guaraná e castanha-do-Brasil.",
		"Sudeste: Produção de 17,7 milhões de toneladas de laranja prevista para 2024.",
		"Sul da Bahia: Projeto de reflorestamento na APA do Pratigi recuperou 140 hectares e revitalizou 100 nascentes.",
		"Mata Atlântica (RJ): Projeto Onda Verde já plantou 2 milhões de mudas em 26 anos.",
		"Amazônia Legal: Reflorestamento de 30 milhões de árvores nativas em 25 áreas desmatadas.",
		"Cerrado (GO/MS/MT): 500 hectares restaurados no projeto Emas-Taquari, conectando parques e beneficiando 51 famílias.",
		"Indústria Eletroeletrônica (SP): Produção deve crescer 3% em 2024, com aumento de semicondutores e motores elétricos.",
		"Campinas (SP): Parques tecnológicos desenvolvendo novos sensores para agricultura e saúde.",
		"Norte e Nordeste: Crescimento de semicondutores para energia solar e hidrogênio verde.",
		"Sul do Brasil: Automação industrial impulsiona modernização de 60 fábricas em 2024.",
		"Região Centro-Oeste: Projetos de robótica colaborativa ampliam exportação de equipamentos industriais.",
		"Frente Oeste (RS): Desenvolvimento de infraestrutura digital e turismo inteligente com tecnologia.",
		"Bahia: Uso de tecnologia quântica em projetos industriais para soluções avançadas.",
		"São Paulo: Indústria de software cresce 8%, com destaque para inteligência artificial em saúde e logística.",
		"Amazônia: Restauração de ecossistemas com biotecnologia para 100 mil hectares até 2025.",
		"Ceará: Ampliação da fabricação de equipamentos para telecomunicações, com 5G liderando a transformação."
	];


		const shuffledHeadlines = shuffleArray([...headlines]); // Embaralha as notícias
		const newsText = shuffledHeadlines.join(' - '); // Cria o texto para o letreiro
		const marquee = document.getElementById('newsMarquee');
		marquee.innerHTML = `
			<img src="https://i.postimg.cc/65gr9cjN/bandeiravermelhaanimada.gif" alt="Bandeira Vermelha">
			${newsText}
		`;
		
	}

	// Chama a função imediatamente para carregar os dados na primeira vez
	fetchNewsTitles();

	function updateProductName(rowIndex, newName) {
		const demandRows = document.querySelectorAll('#finalDemandInputs tr');
		const sectorHeader = document.querySelector(`#inputTable thead tr th:nth-child(${rowIndex + 2}) input`);

		if (demandRows[rowIndex]) {
			const productCell = demandRows[rowIndex].querySelector('td:first-child');
			if (productCell) {
				productCell.textContent = newName; // Atualiza o nome do produto na tabela Demanda Final
			}
		}
		
		if (sectorHeader) { 
			if (newName.includes("Rede")) {
				sectorHeader.value = newName;
			} else {
				sectorHeader.value = `Produção de ${newName}`;
			}
		}

		//showNotification(`Produto ${rowIndex + 1} atualizado para: ${newName}`, true);
	}

	function updateSectorName(colIndex, newName) {
		const thead = document.querySelector('#inputTable thead tr');
		const headerCell = thead.querySelectorAll('th')[colIndex + 1]; // Coluna começa no índice 1

		if (headerCell) {
			const input = headerCell.querySelector('input[type="text"]');
			if (input) {
				input.value = newName; // Atualiza o título da coluna
			}
		}

		//showNotification(`Setor ${colIndex + 1} atualizado para: ${newName}`, true);
	}


	document.getElementById('downloadDataButton').addEventListener('click', () => {
		try {
			const csvContent = generateCSV();
			downloadCSV(csvContent, 'dados_economia.csv');
		} catch (error) {
			console.error('Erro ao gerar o arquivo CSV:', error);
		}
	});

	function generateCSV() {
		const data = collectAllData();

		let csv = '';

		// Nomes dos Produtos
		csv += 'Produtos\n';
		csv += data.productNames.join(',') + '\n\n';

		// Matriz Tecnológica
		csv += 'Matriz Tecnológica\n';
		data.techMatrix.forEach((row, rowIndex) => {
			csv += `${data.productNames[rowIndex]},${row.map(value => value || 0).join(',')}\n`;
		});
		csv += '\n';

		// Demanda Final
		csv += 'Demanda Final\n';
		data.finalDemand.forEach((value, rowIndex) => {
			csv += `${data.productNames[rowIndex]},${value || 0}\n`;
		});
		csv += '\n';

		// Dados de Otimização
		csv += 'Otimização\n';
		for (const [index, inputs] of Object.entries(data.optimizationInputs)) {
			const values = [
				data.productNames[index] || '',
				inputs.workerLimit || 0,
				inputs.workerHours || 0,
				inputs.productionTime || 0,
				inputs.nightShift ? 'true' : 'false',
				inputs.weeklyScale || 0,
				optimizedStatus[index] ? 'true' : 'false'
			];
			csv += values.join(',') + '\n';
		}
		csv += '\n';

		// Resultados da Planificação
		csv += 'Resultados da Planificação\n';
		for (const [index, results] of Object.entries(data.optimizationResults)) {
			const values = [
				data.productNames[index] || '',
				results.totalHours || 0,
				results.workersNeeded || 0,
				results.factoriesNeeded || 0,
				results.totalShifts || 0,
				results.minimumProductionTime || 0,
				results.totalEmploymentPeriod || ''
			];
			csv += values.join(',') + '\n';
		}

		return csv;
	}






	function downloadCSV(content, filename) {
		const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
		const link = document.createElement('a');
		link.href = URL.createObjectURL(blob);
		link.download = filename;
		link.click();
	}


	document.getElementById('uploadDataButton').addEventListener('click', () => {
		const fileInput = document.getElementById('uploadInput');
		fileInput.click();
	});

	document.getElementById('uploadInput').addEventListener('change', async (event) => {
		const file = event.target.files[0];
		if (file) {
			try {
				const content = await file.text();
				restoreDataFromCSV(content);
				console.info('Dados restaurados com sucesso!');
			} catch (error) {
				console.error('Erro ao restaurar os dados:', error);
				console.info('Ocorreu um erro ao restaurar os dados. Verifique o arquivo CSV.');
			}
		}
	});

	function restoreDataFromCSV(content) {
		const lines = content.split('\n').map(line => line.trim()).filter(line => line);
		let section = null;

		const data = {
			productNames: [],
			techMatrix: [],
			finalDemand: [],
			optimizationInputs: {},
			optimizationResults: {}
		};

		lines.forEach(line => {
			const cells = line.split(',');

			if (line === 'Produtos') {
				section = 'productNames';
			} else if (line === 'Matriz Tecnológica') {
				section = 'techMatrix';
			} else if (line === 'Demanda Final') {
				section = 'finalDemand';
			} else if (line === 'Otimização') {
				section = 'optimizationInputs';
			} else if (line === 'Resultados da Planificação') {
				section = 'optimizationResults';
			} else {
				if (section === 'productNames') {
					data.productNames = cells.map(name => name.trim());
				} else if (section === 'techMatrix') {
					if (cells.length > 1) {
						const values = cells.slice(1).map(value => parseFloat(value) || 0);
						data.techMatrix.push(values);
					}
				} else if (section === 'finalDemand') {
					if (cells.length === 2) {
						const demand = parseFloat(cells[1]) || 0;
						data.finalDemand.push(demand);
					}
				} else if (section === 'optimizationInputs') {
					const [
						productName,
						workerLimit,
						workerHours,
						productionTime,
						nightShift,
						weeklyScale,
						optimized
					] = cells;

					const productIndex = data.productNames.indexOf(productName);

					if (productIndex !== -1) {
						const inputs = {
							workerLimit: parseFloat(workerLimit) || 0,
							workerHours: parseFloat(workerHours) || 0,
							productionTime: parseFloat(productionTime) || 0,
							nightShift: nightShift === 'true',
							weeklyScale: parseInt(weeklyScale, 10) || 0
						};

						// Salvar os dados no objeto e processar se otimizados
						data.optimizationInputs[productIndex] = inputs;
						if (optimized === 'true') {
							optimizationInputs[productIndex] = inputs;
							saveOptimizationInputsForProduct(productIndex); // Chama a função para salvar e processar
						}
					}
				}
			}
		});

		// Validação e ajuste de dados restaurados
		if (data.finalDemand.length !== data.productNames.length) {
			while (data.finalDemand.length < data.productNames.length) {
				data.finalDemand.push(0);
			}
		}

		// Redimensionar a tabela e carregar os dados
		resizeTableForData(data.productNames.length, data.techMatrix[0]?.length || 0);
		populateTechMatrix(data.techMatrix, data.productNames);
		populateFinalDemand(data.finalDemand);

		// Atualiza o status de otimização e os botões
		Object.keys(optimizationInputs).forEach(index => {
			const productIndex = parseInt(index, 10);
			const hasOptimization = isOptimizationDataComplete(productIndex);
			optimizedStatus[productIndex] = hasOptimization; // Define o status
			updateOptimizeButtonColor(productIndex); // Atualiza a cor do botão
		});

		// Executar a função de planificação automaticamente
		planify();

		console.info('Dados restaurados e planificados com sucesso!');
	}

	function saveOptimizationInputsForProduct(productIndex) {
		const inputs = optimizationInputs[productIndex];
		if (!inputs) return;

		// Salva os dados no objeto de otimização
		optimizationInputs[productIndex] = inputs;
		optimizedStatus[productIndex] = true;

		// Atualiza o botão na tabela "Demanda Final"
		updateOptimizeButtonColor(productIndex);

		// Recalcula a otimização para este produto
		performOptimization(productIndex);
	}

	function saveOptimizationInputsForProduct(productIndex) {
		const inputs = optimizationInputs[productIndex];
		if (!inputs) return;

		// Salva os dados no objeto de otimização
		optimizationInputs[productIndex] = inputs;
		optimizedStatus[productIndex] = true;

		// Atualiza o botão na tabela "Demanda Final"
		updateOptimizeButtonColor(productIndex);

		// Recalcula a otimização para este produto
		performOptimization(productIndex);

		// Atualiza os resultados da "Planificação Otimizada"
		const resultDiv = document.getElementById('result');
		if (resultDiv && resultDiv.innerHTML.trim() !== '') {
			planify(); // Reprocessa os dados da planificação
		}
	}







	function restoreFromCSV(content) {
		const lines = content.split('\n').map(line => line.trim()).filter(line => line);
		let section = null;

		const data = {
			productNames: [],
			techMatrix: [],
			finalDemand: [],
			optimizationInputs: {},
			optimizationResults: {}
		};

		lines.forEach(line => {
			if (line === 'Produtos') {
				section = 'productNames';
			} else if (line === 'Matriz Tecnológica') {
				section = 'techMatrix';
			} else if (line === 'Demanda Final') {
				section = 'finalDemand';
			} else if (line === 'Otimização') {
				section = 'optimizationInputs';
			} else if (line === 'Resultados da Planificação') {
				section = 'optimizationResults';
			} else {
				const cells = line.split(',');

				if (section === 'productNames') {
					data.productNames = cells;
				} else if (section === 'techMatrix') {
					const productName = cells[0];
					const values = cells.slice(1).map(Number);
					data.techMatrix.push(values);
					if (!data.productNames.includes(productName)) {
						data.productNames.push(productName);
					}
				} else if (section === 'finalDemand') {
					const productName = cells[0];
					const value = Number(cells[1]);
					data.finalDemand.push(value);
				} else if (section === 'optimizationInputs') {
					const [productName, workerLimit, workerHours, productionTime, nightShift, weeklyScale] = cells;
					const productIndex = data.productNames.indexOf(productName);
					data.optimizationInputs[productIndex] = {
						workerLimit: parseFloat(workerLimit),
						workerHours: parseFloat(workerHours),
						productionTime: parseFloat(productionTime),
						nightShift: nightShift === 'true',
						weeklyScale: parseInt(weeklyScale, 10)
					};
				} else if (section === 'optimizationResults') {
					const [
						productName,
						totalHours,
						workersNeeded,
						factoriesNeeded,
						totalShifts,
						minimumProductionTime,
						totalEmploymentPeriod
					] = cells;
					const productIndex = data.productNames.indexOf(productName);
					data.optimizationResults[productIndex] = {
						totalHours: parseFloat(totalHours),
						workersNeeded: parseInt(workersNeeded, 10),
						factoriesNeeded: parseFloat(factoriesNeeded),
						totalShifts: parseInt(totalShifts, 10),
						minimumProductionTime: parseInt(minimumProductionTime, 10),
						totalEmploymentPeriod
					};
				}
			}
		});

		// Restaurar os dados
		resizeTableForData(data.techMatrix.length, data.techMatrix[0]?.length || 0);
		populateTechMatrix(data.techMatrix, data.productNames);
		populateFinalDemand(data.finalDemand);
		optimizationInputs = data.optimizationInputs;
		optimizationResults = data.optimizationResults;
		planify(); // Recalcula os resultados
		
		// Atualiza os botões com base nos dados carregados
		Object.keys(optimizationInputs).forEach(index => {
			updateOptimizeButtonColor(parseInt(index, 10));
		});
		
	}



	function resizeTableForData(numRows, numCols) {
		document.getElementById('numRows').value = numRows;
		document.getElementById('numCols').value = numCols;
		resizeTable(); // Redimensiona a tabela usando a função existente
	}






	function populateTechMatrix(techMatrix, productNames) {
		const thead = document.getElementById('inputTable').querySelector('thead tr');
		const tbody = document.getElementById('inputTable').querySelector('tbody');

		// Atualizar os títulos das colunas
		thead.innerHTML = '<th>Produtos / Setor Produtivo</th>'; // Redefine o cabeçalho
		productNames.forEach(productName => {
			const sectorHeader = document.createElement('th');
			const sectorInput = document.createElement('input');
			sectorInput.type = 'text';
			sectorInput.value = `Produção de ${productName}`;
			sectorInput.readOnly = true; // Define como apenas leitura
			addTooltipBehavior(sectorInput); // Adiciona o comportamento de tooltip
			sectorHeader.appendChild(sectorInput);
			thead.appendChild(sectorHeader);
		});

		// Atualizar os dados da tabela
		tbody.innerHTML = ''; // Limpa a tabela existente
		techMatrix.forEach((row, rowIndex) => {
			const tr = document.createElement('tr');
			const productNameCell = document.createElement('td');
			const productInput = document.createElement('input');
			productInput.type = 'text';
			productInput.value = productNames[rowIndex];
			productInput.oninput = () => updateProductName(rowIndex, productInput.value);
			productNameCell.appendChild(productInput);
			tr.appendChild(productNameCell);

			row.forEach(value => {
				const cell = document.createElement('td');
				const input = document.createElement('input');
				input.type = 'number';
				input.value = value;
				cell.appendChild(input);
				addHighlightBehavior(cell); // Adiciona o comportamento de destaque
				tr.appendChild(cell);
			});

			tbody.appendChild(tr);
		});
	}


	function populateFinalDemand(finalDemand) {
		const demandContainer = document.getElementById('finalDemandInputs');
		demandContainer.innerHTML = ''; // Limpa a tabela antes de preencher

		finalDemand.forEach((demand, index) => {
			const row = document.createElement('tr');

			// Coluna do nome do produto
			const productNameCell = document.createElement('td');
			productNameCell.textContent = getProductNames()[index] || `Produto ${index + 1}`;
			row.appendChild(productNameCell);

			// Entrada de demanda
			const demandInputCell = document.createElement('td');
			const demandInput = document.createElement('input');
			demandInput.type = 'number';
			demandInput.value = demand;
			demandInput.id = `demand${index}`;
			demandInputCell.appendChild(demandInput);
			row.appendChild(demandInputCell);

			// Botão de ação
			const actionCell = document.createElement('td');
			const optimizeButton = document.createElement('button');
			optimizeButton.textContent = 'Otimizar';
			optimizeButton.onclick = () => openOptimizationModal(index); // Reatribuir o evento de clique
			actionCell.appendChild(optimizeButton);
			row.appendChild(actionCell);

			demandContainer.appendChild(row);

			// Atualizar a cor do botão com base no status de otimização
			updateOptimizeButtonColor(index);
		});
	}


	function collectAllData() {
		// Obter nomes dos produtos
		const productNames = getProductNames();

		// Obter dados da tabela "Matriz Tecnológica"
		const techMatrix = getTableData();

		// Obter dados da tabela "Demanda Final"
		const finalDemand = getFinalDemand();
		
		const instancePrepositionJurisdictionUUID = user.instancePrepositionJurisdictionUUID;

		return {
			productNames,       // Nomes dos produtos
			techMatrix,         // Dados da Matriz Tecnológica
			finalDemand,        // Dados da Demanda Final
			optimizationInputs, // Configurações de otimização (objeto global)
			optimizationResults, // Resultados da planificação (objeto global)
			instancePrepositionJurisdictionUUID			//Instância + Preposição + Jurisdição
		};
	}

	function updateColumnTitles(productNames) {
		const headerRow = document.getElementById('inputTable').querySelector('thead tr');

		// Ignorar a primeira célula (que contém "Produtos / Setores Produtivos")
		const columnHeaders = headerRow.querySelectorAll('th');

		productNames.forEach((productName, index) => {
			const columnHeader = columnHeaders[index + 1]; // +1 para ignorar a primeira célula
			if (columnHeader) {
				const input = columnHeader.querySelector('input');
				if (input) {
					input.value = `Produção de ${productName}`; // Atualiza o título
					input.readOnly = true; // Configura como somente leitura
					addTooltipBehavior(input); // Adiciona o comportamento de tooltip
				}
			}
		});
	}

	// Dados para salvar e carregar os dados online
	const endpoint = "data";
	//const apiKey = 'ixYIiBIuxiS68RgTT7qYB50K3jOiUKMK9bQFPjAcRd';
	//let apiUrl = `https://api.jsonsilo.com/${endpoint}`;
	let apiUrl = `${window.location.origin}/jsonServer/${endpoint}`;

	// Headers para a requisição
	const headers = {
		'Content-Type': 'application/json'
	};

	// Proxy
	//const proxyUrl = "https://api.allorigins.win/raw?url=";
	//apiUrl = proxyUrl + encodeURIComponent(apiUrl);

	function sendDataToJsonBin() {
		if (!userIsLoggedIn || !user) {
			showNotification("Você precisa estar logado para enviar dados.", false);
			return;
		}

		const instanceKey = user.instancePrepositionJurisdictionUUID;

		const setorUnidade = document.getElementById("setorUnidade").value.trim();

		const estoqueDemandaData = [];
		document.querySelectorAll("#estoqueDemandaTable tbody tr").forEach(row => {
			const bemDeProducao = row.cells[0].textContent.trim();
			const estoque = row.cells[1].querySelector("input").value.trim();
			const demanda = row.cells[2].querySelector("input").value.trim();
			estoqueDemandaData.push({ bemDeProducao, estoque, demanda });
		});

		const producaoMetaData = [];
		document.querySelectorAll("#producaoMetaTable tbody tr").forEach(row => {
			const produto = row.cells[0].querySelector("input").value.trim();
			const quantidadeProduzida = row.cells[1].querySelector("input").value.trim();
			const quantidadeMeta = row.cells[2].querySelector("input").value.trim();
			producaoMetaData.push({ produto, quantidadeProduzida, quantidadeMeta });
		});

		const comiteColTitle = document.getElementById("comiteColTitle").value.trim();

		//De Trabalhadores
		const comiteAssociadoDeTrabalhador = document.getElementById("comiteAssociadoDeTrabalhador").value.trim();
		const associacaoDeMoradoresAssociadaDeTrabalhador = document.getElementById("associacaoDeMoradoresAssociadaDeTrabalhador").value.trim();
		const hoursAtElectronicPoint = Number(document.getElementById("hoursAtElectronicPoint").value)
		
		console.log(`hoursAtElectronicPoint/totalSocialWork: ${hoursAtElectronicPoint}/${totalSocialWork} = ${hoursAtElectronicPoint/totalSocialWork}`);
		
		const partipacaoIndividualEstimadaNoTrabalhoSocial = hoursAtElectronicPoint/totalSocialWork;   //document.getElementById("partipacaoIndividualEstimadaNoTrabalhoSocial").value.concat("e-13")); //quando exibir na tela exibe multiplicado por esse valor
		
		//-----------

		const propostaTrabalhadoresData = { ...propostaDados };

		// Coleta os dados da segunda coluna da tabela "Vetor Tecnológico"
		const vetorTecnologicoData = [];
		document.querySelectorAll("#vetorTecnologicoTable tbody tr").forEach(row => {
			const secondColumnInput = row.cells[1]?.querySelector("input");
			if (secondColumnInput) {
				vetorTecnologicoData.push(secondColumnInput.value.trim());
			}
		});

		// Coleta os novos campos da seção "Informações da Unidade Produtiva"
		const limiteEfetivoTrabalhadores = document.getElementById("limiteEfetivoTrabalhadores").value.trim();
		
		let conselhoPopularAssociadoDeComiteOuTrabalhadorData;
		
		if(user.instancePrepositionJurisdictionUUID.includes("WorkerUUID")){
			conselhoPopularAssociadoDeComiteOuTrabalhadorData = document.getElementById("conselhoPopularAssociadoDeComiteOuTrabalhadorTelaTrabalhador").value.trim();
		} else{
			conselhoPopularAssociadoDeComiteOuTrabalhadorData = document.getElementById("conselhoPopularAssociadoDeComiteOuTrabalhador").value.trim();
		}

		// Coleta o campo da seção "Tamanho da Economia"
		const conselhoPopularAssociadoDeConselhoPopular = document.getElementById("conselhoPopularAssociadoDeConselhoPopular").value.trim();

		const dataToSave = {
			inputTable: getTableData(),
			productNames: getProductNames(),
			sectorNames: getSectorNames(),
			finalDemand: getFinalDemand(),
			optimizationInputs,
			optimizationResults,
			setorUnidade,
			limiteEfetivoTrabalhadores, // Novo campo da seção "Informações da Unidade Produtiva"
			conselhoPopularAssociadoDeComiteOuTrabalhador: conselhoPopularAssociadoDeComiteOuTrabalhadorData,
			conselhoPopularAssociadoDeConselhoPopular, // Novo campo da seção "Tamanho da Economia"
			estoqueDemanda: estoqueDemandaData,
			producaoMeta: producaoMetaData,
			comiteColTitle,
			propostaTrabalhadores: propostaTrabalhadoresData,
			vetorTecnologico: vetorTecnologicoData, // Adiciona os dados coletados
			totalSocialWorkDessaJurisdicao, // Valor padrão inicial
			comiteAssociadoDeTrabalhador,
			associacaoDeMoradoresAssociadaDeTrabalhador,
			partipacaoIndividualEstimadaNoTrabalhoSocial,
			hoursAtElectronicPoint,
			effectivelyPlannedProductionTime
		};

		fetch(apiUrl, {
			method: 'GET',
			headers: headers
		})
			.then(response => response.json())
			.then(binData => {
				const record = binData || {};
				record[instanceKey] = { ...record[instanceKey], ...dataToSave };

				return fetch(apiUrl, {
					method: 'PUT',
					headers: headers,
					body: JSON.stringify(record)
				});
			})
			.then(() => showNotification("Dados enviados com sucesso!", true))
			.catch(err => console.error("Erro ao enviar dados:", err));
	}


	function fetchDataFromJsonBin() {

		// Reseta os dados anteriores antes de carregar novos dados
		previousTableData = [];

		if (!userIsLoggedIn || !user) {
			showNotification("Você precisa estar logado para receber dados.", false);
			return;
		}

		// Limpa os dados antigos antes de carregar novos
		optimizationInputs = {};
		optimizationResults = {};
		optimizedStatus = {};

		const instanceKey = user.instancePrepositionJurisdictionUUID;

		fetch(apiUrl, {
			method: 'GET',
			headers: headers
		})
			.then(response => response.json())
			.then(binData => {
				const record = binData || {};
				const instanceData = record[instanceKey];

				if(user.instancePrepositionJurisdictionUUID.includes("WorkerUUID")){
					//Trabalhador não conselheiro
					document.getElementById("name").value = user.name;
					generateQRCode(user.uuid);
				}

				if (instanceData) {

					// Obter dimensões da matriz tecnológica
					const numProducts = instanceData.productNames?.length || 0;
					const numSectors = instanceData.sectorNames?.length || 0;

					// Atualizar os campos "Número de produtos" e "Número de Setores Produtivos"
					document.getElementById('numRows').value = numProducts;
					document.getElementById('numCols').value = numSectors;

					if(!record[conselhoMundialKey]){
						showNotification("Cadastre um Conselho Popular Mundial.", false);
					}

					totalSocialWork = record[conselhoMundialKey]?.totalSocialWorkDessaJurisdicao || "Ainda não há registro mundial de trabalho social total.";

					// Executar a função de redimensionar tabela
					resizeTable();

					fillTableWithData(instanceData.inputTable || []);
					setProductNames(instanceData.productNames || []);
					setSectorNames(instanceData.sectorNames || []);
					setFinalDemand(instanceData.finalDemand || []);
					optimizationInputs = instanceData.optimizationInputs || {};
					optimizationResults = instanceData.optimizationResults || {};

					synchronizeFinalDemandProducts();
					updateAllOptimizeButtons();
					planify(); // Executa a planificação automaticamente após carregar os dados
					showNotification("Dados recebidos com sucesso!", true);

					if(user.instancePrepositionJurisdictionUUID.includes("WorkerUUID")){
						//Trabalhador não conselheiro

						document.getElementById("conselhoPopularAssociadoDeComiteOuTrabalhadorTelaTrabalhador").value = instanceData.conselhoPopularAssociadoDeComiteOuTrabalhador;
						document.getElementById("comiteAssociadoDeTrabalhador").value = instanceData.comiteAssociadoDeTrabalhador;
						document.getElementById("associacaoDeMoradoresAssociadaDeTrabalhador").value = instanceData.associacaoDeMoradoresAssociadaDeTrabalhador;
						document.getElementById("hoursAtElectronicPoint").value = Number(instanceData.hoursAtElectronicPoint);
						document.getElementById("totalSocialWork").value = totalSocialWork;
						
						console.log(`hoursAtElectronicPoint/totalSocialWork: ${instanceData.hoursAtElectronicPoint}/${totalSocialWork} = ${instanceData.hoursAtElectronicPoint/totalSocialWork}`);
						
						document.getElementById("partipacaoIndividualEstimadaNoTrabalhoSocial").value = ((instanceData.hoursAtElectronicPoint/totalSocialWork)*Number("1e13")).toFixed(2);
						
					}else{
						//Conselheiro
						
					}

					// Ajustar o campo "Setor"
					if (instanceData.setorUnidade) {
						document.getElementById("setorUnidade").value = instanceData.setorUnidade;
					}

					// Carregar os novos campos da seção "Informações da Unidade Produtiva"
					if (instanceData.limiteEfetivoTrabalhadores !== undefined) {
						document.getElementById("limiteEfetivoTrabalhadores").value = instanceData.limiteEfetivoTrabalhadores;
					}

					if (instanceData.conselhoPopularAssociadoDeComiteOuTrabalhador !== undefined) {
						document.getElementById("conselhoPopularAssociadoDeComiteOuTrabalhador").value = instanceData.conselhoPopularAssociadoDeComiteOuTrabalhador;
					}

					// Carregar conselhoPopularAssociadoDeConselhoPopular a seção "Tamanho da Economia"
					if (instanceData.conselhoPopularAssociadoDeConselhoPopular !== undefined) {
						document.getElementById("conselhoPopularAssociadoDeConselhoPopular").value = instanceData.conselhoPopularAssociadoDeConselhoPopular;
					}

					// Ajustar "Quantidade de Bens de Produção" e popula "Estoque e Demanda"
					if (instanceData.estoqueDemanda) {
						const estoqueDemandaBody = document.querySelector("#estoqueDemandaTable tbody");
						const requiredRows = instanceData.estoqueDemanda.length;

						document.getElementById('quantidadeBensProducao').value = requiredRows;

						if (estoqueDemandaBody) {
							estoqueDemandaBody.innerHTML = ""; // Limpa a tabela

							instanceData.estoqueDemanda.forEach((item, index) => {
								const row = document.createElement("tr");

								const bemCell = document.createElement("td");
								bemCell.textContent = item.bemDeProducao || `Bem ${index + 1}`;

								const estoqueCell = document.createElement("td");
								const estoqueInput = document.createElement("input");
								estoqueInput.type = "number";
								estoqueInput.value = item.estoque || 0;
								estoqueCell.appendChild(estoqueInput);

								const demandaCell = document.createElement("td");
								const demandaInput = document.createElement("input");
								demandaInput.type = "number";
								demandaInput.value = item.demanda || 0;
								demandaInput.readOnly = true;
								demandaCell.appendChild(demandaInput);

								row.appendChild(bemCell);
								row.appendChild(estoqueCell);
								row.appendChild(demandaCell);
								estoqueDemandaBody.appendChild(row);
							});
						}
					}

					// Ajustar a tabela "Vetor Tecnológico"
					if (instanceData.estoqueDemanda) {
						const vetorTecnologicoBody = document.querySelector("#vetorTecnologicoTable tbody");
						const estoqueDemandaBody = document.querySelector("#estoqueDemandaTable tbody");
						const requiredRows = instanceData.estoqueDemanda.length;

						if (vetorTecnologicoBody && estoqueDemandaBody) {
							vetorTecnologicoBody.innerHTML = ""; // Limpa a tabela

							instanceData.estoqueDemanda.forEach((item, index) => {
								const row = document.createElement("tr");

								// Coluna: Nome do Produto (Bem de Produção)
								const bemDeProducaoCell = document.createElement("td");
								const bemInput = document.createElement("input");
								bemInput.type = "text";
								bemInput.value = item.bemDeProducao || `Bem ${index + 1}`;

								// Sincroniza com a tabela "Estoque e Demanda"
								bemInput.addEventListener("input", () => {
									const estoqueRow = estoqueDemandaBody.querySelectorAll("tr")[index];
									if (estoqueRow) {
										const bemCell = estoqueRow.querySelector("td:first-child");
										if (bemCell) {
											bemCell.textContent = bemInput.value;
										}
									}
								});

								bemDeProducaoCell.appendChild(bemInput);

								// Coluna: Valor (inicializa com 0 ou valor carregado)
								const valorCell = document.createElement("td");
								const valorInput = document.createElement("input");
								valorInput.type = "number";
								valorInput.value = instanceData.vetorTecnologico?.[index] || 0;
								valorCell.appendChild(valorInput);

								row.appendChild(bemDeProducaoCell);
								row.appendChild(valorCell);
								vetorTecnologicoBody.appendChild(row);
							});
						}
					}

					// Carregar o título do comitê
					if (instanceData.comiteColTitle) {
						document.getElementById("comiteColTitle").value = instanceData.comiteColTitle;
					}

					// Carregar dados do modal "Proposta para demais Trabalhadores"
					if (instanceData.propostaTrabalhadores) {
						propostaDados = instanceData.propostaTrabalhadores;

						document.getElementById("workerLimitProposta").value = propostaDados.workerLimit || 0;
						document.getElementById("workerHoursProposta").value = propostaDados.workerHours || 0;
						document.getElementById("productionTimeProposta").value = propostaDados.productionTime || 0;
						document.getElementById("nightShiftProposta").checked = propostaDados.nightShift || false;
						document.getElementById("weeklyScaleProposta").value = propostaDados.weeklyScale || 0;
					}

					// Carregar dados da tabela "Produção e Meta"
					if (instanceData.producaoMeta) {
						
						const producaoMetaBody = document.querySelector("#producaoMetaTable tbody");
						producaoMetaBody.innerHTML = ""; // Limpa a tabela

						instanceData.producaoMeta.forEach((item, index) => {
							const row = document.createElement("tr");

							// Coluna: Produto
							const produtoCell = document.createElement("td");
							const produtoInput = document.createElement("input");
							produtoInput.type = "text";
							produtoInput.value = item.produto || `Produto ${index + 1}`;
							produtoCell.appendChild(produtoInput);

							// Coluna: Quantidade Produzida
							const quantidadeProduzidaCell = document.createElement("td");
							const quantidadeProduzidaInput = document.createElement("input");
							quantidadeProduzidaInput.type = "number";
							quantidadeProduzidaInput.id = "producedQuantity";
							quantidadeProduzidaInput.value = parseFloat(item.quantidadeProduzida).toFixed(3) || 0;
							quantidadeProduzidaCell.appendChild(quantidadeProduzidaInput);

							// Coluna: Quantidade Meta
							const quantidadeMetaCell = document.createElement("td");
							const quantidadeMetaInput = document.createElement("input");
							quantidadeMetaInput.type = "number";
							quantidadeMetaInput.value = item.quantidadeMeta || 0;
							quantidadeMetaInput.id = "pendingProductionQuantity";
							quantidadeMetaInput.readOnly = true;
							quantidadeMetaCell.appendChild(quantidadeMetaInput);

							// Coluna: Planejamento (botão)
							const planejamentoCell = document.createElement("td");
							const planejamentoButton = document.createElement("button");
							planejamentoButton.className = "btn";
							planejamentoButton.textContent = "Planejamento";
							planejamentoButton.onclick = () => openProducaoMetaModal();
							planejamentoCell.appendChild(planejamentoButton);

							// Adiciona as células à linha
							row.appendChild(produtoCell);
							row.appendChild(quantidadeProduzidaCell);
							row.appendChild(quantidadeMetaCell);
							row.appendChild(planejamentoCell);

							// Adiciona a linha ao corpo da tabela
							producaoMetaBody.appendChild(row);

							// Inicializa o evento e executa a atualização inicial
							produtoInput.addEventListener('input', atualizarTituloColunaVetorTecnologico);
							atualizarTituloColunaVetorTecnologico(); // Atualiza o título na inicialização
						});
					
						// Carregue os dados e atribua às variáveis
						 
						 const produtoInput = document.querySelector('#producaoMetaTable tbody tr td:first-child input');
						 
						const limiteEfetivoTrabalhadores = document.getElementById("limiteEfetivoTrabalhadores").value.trim();
						const comiteColTitle = instanceData.comiteColTitle;
						const productName = produtoInput.value || "Produto";
						const minimumProductionTime = instanceData.producaoMeta; //ver se vou ter que somar tudo pra tirar a media ponderada como fiz antes. multiplicar o valor do setor pelo peso pra ter a proporção pra essa fabrica.
						const workShift = instanceData.workShift;
						const workerHours = instanceData.workerHours;
						const weeklyScale = instanceData.weeklyScale;
						const totalEmploymentPeriod = instanceData.totalEmploymentPeriod;
						
						
					} else {
						console.error("Nenhum dado encontrado para a instância:", instanceKey);
					}

				} else {
					showNotification("Nenhum dado encontrado para sua instância.", false);
				}
			})
			.catch(err => console.error("Erro ao receber dados do JSONBin:", err));
	}



	document.getElementById("sendDataButton").addEventListener("click", sendDataToJsonBin);

	// Suponha um botão para restaurar dados
	document.getElementById("fetchDataButton").addEventListener("click", () => {
		const binId = "67454301e41b4d34e45ab292"; //binID dos dados que se deseja restaurar
		if (binId) {
			fetchDataFromJsonBin(binId);
		}
	});

	function restoreDataFromJSON(data) {
		try {
		
			// Determina o número de produtos e setores com base nos dados recebidos
			const numRows = data.productNames.length;
			const numCols = data.techMatrix[0]?.length || 0;

			// Atualiza os valores dos inputs do Tamanho da Economia
			document.getElementById('numRows').value = numRows;
			document.getElementById('numCols').value = numCols;

			// Redimensiona a tabela principal
			resizeTable();

			// Preenche os dados recebidos na interface
			const tbody = document.getElementById('inputTechnologicalMatrixTableBody');
			tbody.innerHTML = '';

			data.productNames.forEach((name, rowIndex) => {
				const row = document.createElement('tr');

				// Nome do produto
				const productNameCell = document.createElement('td');
				const productInput = document.createElement('input');
				productInput.type = 'text';
				productInput.value = name;
				productInput.oninput = (e) => updateProductName(rowIndex, e.target.value);
				productNameCell.appendChild(productInput);
				row.appendChild(productNameCell);

				// Dados da Matriz Tecnológica
				data.techMatrix[rowIndex].forEach(value => {
					const cell = document.createElement('td');
					const input = document.createElement('input');
					input.type = 'number';
					input.value = value;
					cell.appendChild(input);
					addHighlightBehavior(cell); // Adiciona o comportamento de destaque
					row.appendChild(cell);
				});

				tbody.appendChild(row);
			});

			// Atualiza a tabela de Demanda Final
			const demandInputsContainer = document.getElementById('finalDemandInputs');
			demandInputsContainer.innerHTML = '';

			data.finalDemand.forEach((value, index) => {
				const demandRow = document.createElement('tr');

				// Nome do produto
				const productNameCell = document.createElement('td');
				productNameCell.textContent = data.productNames[index];
				demandRow.appendChild(productNameCell);

				// Valor da demanda
				const demandInputCell = document.createElement('td');
				const demandInput = document.createElement('input');
				demandInput.type = 'number';
				demandInput.value = value;
				demandInput.id = `demand${index}`;
				demandInputCell.appendChild(demandInput);
				demandRow.appendChild(demandInputCell);

				// Botão de otimização
				const buttonCell = document.createElement('td');
				const button = document.createElement('button');
				button.textContent = 'Otimizar';
				button.onclick = () => openOptimizationModal(index);
				buttonCell.appendChild(button);
				demandRow.appendChild(buttonCell);

				demandInputsContainer.appendChild(demandRow);
			});

			// Preenche os dados de "Parâmetros de Otimização" para os produtos
			Object.keys(data.optimizationInputs).forEach(index => {
				const productIndex = parseInt(index, 10);
				const inputs = data.optimizationInputs[productIndex];

				if (inputs) {
					optimizationInputs[productIndex] = {
						workerLimit: inputs.workerLimit || 0,
						workerHours: inputs.workerHours || 0,
						productionTime: inputs.productionTime || 0,
						nightShift: inputs.nightShift || false,
						weeklyScale: inputs.weeklyScale || 0
					};
				}
			});

			// Atualiza o status de otimização e os botões
			Object.keys(optimizationInputs).forEach(index => {
				const productIndex = parseInt(index, 10);
				const hasOptimization = isOptimizationDataComplete(productIndex);
				optimizedStatus[productIndex] = hasOptimization; // Define o status
				updateOptimizeButtonColor(productIndex); // Atualiza a cor do botão
			});

			console.info('Dados restaurados com sucesso!');
			
			// Chama a função planify automaticamente após carregar os dados
			planify();
			
		} catch (error) {
			console.error('Erro ao restaurar os dados:', error);
		}
	}



	function convertJSONToCSV(data) {
		let csv = "";

		// Nomes dos Produtos
		csv += "Produtos\n";
		csv += data.productNames.join(",") + "\n\n";

		// Matriz Tecnológica
		csv += "Matriz Tecnológica\n";
		data.techMatrix.forEach((row, rowIndex) => {
			csv += `${data.productNames[rowIndex]},${row.map(value => value || 0).join(",")}\n`;
		});
		csv += "\n";

		// Demanda Final
		csv += "Demanda Final\n";
		data.finalDemand.forEach((value, rowIndex) => {
			csv += `${data.productNames[rowIndex]},${value || 0}\n`;
		});
		csv += "\n";

		// Dados de Otimização
		if (data.optimizationInputs) {
			csv += "Otimização\n";
			for (const [index, inputs] of Object.entries(data.optimizationInputs)) {
				const values = [
					data.productNames[index] || "",
					inputs.workerLimit || 0,
					inputs.workerHours || 0,
					inputs.productionTime || 0,
					inputs.nightShift ? "true" : "false",
					inputs.weeklyScale || 0,
					"true" // Supondo que os dados de JSON incluem otimizações feitas
				];
				csv += values.join(",") + "\n";
			}
			csv += "\n";
		}

		// Resultados da Planificação
		if (data.optimizationResults) {
			csv += "Resultados da Planificação\n";
			for (const [index, results] of Object.entries(data.optimizationResults)) {
				const values = [
					data.productNames[index] || "",
					results.totalHours || 0,
					results.workersNeeded || 0,
					results.factoriesNeeded || 0,
					results.totalShifts || 0,
					results.minimumProductionTime || 0,
					results.totalEmploymentPeriod || ""
				];
				csv += values.join(",") + "\n";
			}
		}

		return csv;
	}

	function isOptimizationDataComplete(productIndex) {
		const inputs = optimizationInputs[productIndex];
		if (!inputs) return false;

		return (
			inputs.workerLimit > 0 &&
			inputs.workerHours > 0 &&
			inputs.productionTime > 0 &&
			inputs.weeklyScale > 0
		);
	}

	// Função para mostrar os campos adicionais quando o Instância é selecionado
		function showFields() {
			const select = document.getElementById('instance');
			const additionalFields = document.getElementById('additionalFields');
			
			if (select.value && !select.value.includes("Trabalhador")) {
				additionalFields.style.display = 'flex'; // Exibe os campos adicionais
			} else {
				additionalFields.style.display = 'none'; // Oculta os campos adicionais
			}
		}

		// Função para mostrar ou ocultar a seção de Login
		   function showLoginSection() {
			const loginSection = document.getElementById("loginSection");
			loginSection.style.display = "block"; // Torna a seção de login visível
			const loginButton = document.getElementById("loginButton");
			loginButton.style.display = "none"; // Oculta o botão "Faça Login"
			// Ocultar os campos de registro, caso estejam visíveis
			document.getElementById('registrationFields').style.display = 'none';
			
			// Rola a página para o topo
			
			// Rola suavemente para o topo da página
			window.scrollTo({
				top: 0,
				behavior: 'smooth',
			});
			
			const usernameField = document.getElementById('username');
			usernameField.focus(); // Move o cursor para o campo "Nome de Usuário"
			
			
			
		}

		// Manter os dados inseridos no formulário quando clicar em "Faça Login"
		document.getElementById("loginButton").addEventListener("click", showLoginSection);

	// Função para mostrar o campo de jurisdição quando uma opção é selecionada
		function showJurisdiction() {
			const select = document.getElementById('instance');
			const jurisdictionContainer = document.getElementById('jurisdictionContainer');
			
			// Exibe o campo apenas se uma opção válida for selecionada
			if (select.value) {
				jurisdictionContainer.style.display = 'flex'; // Exibe o campo com layout flex
				jurisdictionContainer.style.alignItems = 'center'; // Centraliza o rótulo e o campo
			} else {
				jurisdictionContainer.style.display = 'none'; // Oculta o campo
			}
		}

		// Função para atualizar o texto do conselho
		function updateCouncilText(event) {
			if (event.key === "Enter") {
				event.preventDefault(); // Impede comportamento padrão do Enter

				const instance = document.getElementById("instance").value;
				const jurisdiction = document.getElementById("jurisdiction").value.trim();
				const preposition = document.getElementById("preposition").value;
				const infoText = document.getElementById("infoText");

				if (!(instance && jurisdiction && preposition)) {
					showNotification("Por favor, preencha todos os campos obrigatórios.", false);
				}
			}
		}

		// Adiciona o evento de Enter no campo de jurisdição
		document.getElementById("jurisdiction").addEventListener("keydown", updateCouncilText);

		// Mostra os campos adicionais ao selecionar o Instância
		document.getElementById("instance").addEventListener("change", showFields);

	// Exibe os campos de registro ao clicar no botão "Cadastre-se"
	function showRegistrationFields() {
		const registrationFields = document.getElementById('registrationFields');
		registrationFields.style.display = 'block'; // Exibe os campos
	}

	async function handleLogin() {
		const usernameField = document.getElementById('username');
		const username = usernameField.value.trim();
		const password = document.getElementById('password').value.trim();

		if (!username || !password) {
			showNotification('Preencha todos os campos de login.', false);
			return;
		}

		try {
			// Buscar dados
			const response = await fetch(apiUrl, {
				method: 'GET',
				headers: headers
			});

			const data = await response.json();  // Parse dos dados em formato JSON

			//console.info("data: ");
			//console.log(data);

			// Verifica se o usuário existe e a senha corresponde
			user = data.users.find(
				user => user.username === username && user.password === password
			);

			if (user) {
				// Define os dados globais do usuário logado
				userIsLoggedIn = true;
				user = {
					username: user.username,
					instance: user.instance,
					pronoun: user.pronoun,
					jurisdiction: user.jurisdiction,
					preposition: user.preposition,
					instancePrepositionJurisdictionUUID: user.instancePrepositionJurisdictionUUID,
					uuid: user.uuid,
					name: user.name
				};

				// Realize outras ações de login aqui, se necessário
				
				if (user.pronoun === 'feminino') {
					showNotification(`Bem-vinda, ${user.name}!`, true);
				} else if (user.pronoun === 'masculino') {
					showNotification(`Bem-vindo, ${user.name}!`, true);
				} else {
					showNotification(`Bem-vinde, ${user.name}!`, true);
				}
				
				// Aplica a classe 'logged-in' ao #globeContainer para aplicar o estilo de login
				const globeContainer = document.getElementById('globeContainer');
				globeContainer.classList.add('logged-in'); // Adiciona a classe para alinhamento à direita
				
				// Exibe a div "logado"
				document.getElementById('logado').style.display = 'block'; // Torna visível
				
				// Oculta a seção de login
				document.getElementById('loginSection').style.display = 'none';
				userIsLoggedIn = true;
				document.getElementById('sendDataButton').style.display = 'inline-block'; // Exibe o botão para enviar dados
				
				// Controle de exibição das divs de telas com base na instância
				
			if (user.instance.includes('Conselho')) {
				document.getElementById('conselheiroDeConselho').style.display = 'block';
				document.getElementById('conselheiroDeComiteDeFabricaOuCampo').style.display = 'none';
				document.getElementById('conselheiroDeAssociacaoDeMoradores').style.display = 'none';
				document.getElementById('trabalhador').style.display = 'none';
				
			} else if (user.instance.includes('Comitê')) {
				document.getElementById('conselheiroDeComiteDeFabricaOuCampo').style.display = 'block';
				document.getElementById('conselheiroDeConselho').style.display = 'none';
				document.getElementById('conselheiroDeAssociacaoDeMoradores').style.display = 'none';
				document.getElementById('trabalhador').style.display = 'none';

				// Atualizar o título da segunda coluna
				const comiteColTitle = document.getElementById('comiteColTitle');
				comiteColTitle.value = user.instance === 'Comitê de Fábrica' ? 'Nome da Fábrica' : 'Nome do Campo';

				// Preencher tabela com valores padrão
				updateVetorTecnologicoTable();
				
			} else if (user.instance.includes('Trabalhador')) {
				document.getElementById('conselheiroDeComiteDeFabricaOuCampo').style.display = 'none';
				document.getElementById('conselheiroDeConselho').style.display = 'none';
				document.getElementById('conselheiroDeAssociacaoDeMoradores').style.display = 'none';
				document.getElementById('trabalhador').style.display = 'block';			
				
			} else {
				// Para Associação de Moradores ou outras instâncias
				document.getElementById('conselheiroDeConselho').style.display = 'none';
				document.getElementById('conselheiroDeComiteDeFabricaOuCampo').style.display = 'none';
				document.getElementById('conselheiroDeAssociacaoDeMoradores').style.display = 'block';
				document.getElementById('trabalhador').style.display = 'none';
			}
				
				// Chama automaticamente a função que recebe os dados online
				setTimeout(() => {
					fetchDataFromJsonBin();
					// Chama automaticamente a função que recebe os dados online
					setTimeout(() => {
						scrollToEndOfPage();
						openProducaoMetaModal();
					}, 2000);
				}, 1000);
				
				} else {
					showNotification('Usuário ou senha inválidos.', false);
					document.getElementById('logado').style.display = 'none'; 
					document.getElementById('conselheiroDeConselho').style.display = 'none';
					document.getElementById('conselheiroDeComiteDeFabricaOuCampo').style.display = 'none';
					document.getElementById('conselheiroDeAssociacaoDeMoradores').style.display = 'none';
				}
		} catch (error) {
			console.error('Erro ao fazer login:', error);
			showNotification('Erro ao autenticar. Tente novamente mais tarde.', false);
			document.getElementById('logado').style.display = 'none'; 
			document.getElementById('conselheiroDeConselho').style.display = 'none';
			document.getElementById('conselheiroDeComiteDeFabricaOuCampo').style.display = 'none';
			document.getElementById('conselheiroDeAssociacaoDeMoradores').style.display = 'none';
		}
	}


	async function handleRegister() {
		const username = document.getElementById('username').value.trim();
		const password = document.getElementById('password').value.trim();
		const pronoun = document.getElementById('pronoun').value;
		const instance = document.getElementById('instance').value;
		const name = document.getElementById('nameRegistration').value;
		
		let space = "";
		let preposition = "";
		let jurisdiction = "";
		let uuid = "";
		let uuidPreposition = "";

		if(instance.includes("Trabalhador")) {
			uuid = generateUUID();
			uuidPreposition = "UUID:";
		}
		else {
			space = " ";
			preposition = document.getElementById('preposition').value;
			jurisdiction = document.getElementById('jurisdiction').value.trim();
		}

		// Combina instance, preposition e jurisdiction
		const instancePrepositionJurisdictionUUID = (`${instance=='Trabalhador'?'Worker':instance}${space}${preposition}${space}${jurisdiction}${space}${uuidPreposition}${space}${uuid}`).trim();

		if (!username || !password || !instance || !pronoun) {
			if(!instance.includes("Trabalhador") && (!jurisdiction || !preposition))
			showNotification('Preencha todos os campos corretamente.', false);
			return;
		}

		try {
			
			// Buscar dados
			const response = await fetch(apiUrl, {
				method: 'GET',
				headers: headers
			});

			const data = await response.json();  // Parse dos dados em formato JSON

			// Certifique-se de que a chave "users" exista no objeto
			if (!data.users) {
				data.users = [];
			}

			// Verifica se o nome de usuário já está registrado
			if (data.users.some(user => user.username === username)) {
				showNotification('Nome de usuário já registrado. Escolha outro.', false);
				return;
			}

			// Adiciona o novo usuário com todos os dados
			data.users.push({
				username,
				password,
				instance,
				pronoun,
				jurisdiction,
				preposition,
				instancePrepositionJurisdictionUUID,
				uuid,
				name
			});

			// Salva de volta online
			await fetch(apiUrl, {
				method: 'PUT',
				headers: headers,
				body: JSON.stringify(data)
			});


			showNotification('Usuário registrado com sucesso!', true);
		} catch (error) {
			console.error('Erro ao salvar usuário:', error);
			showNotification('Erro ao registrar usuário. Tente novamente mais tarde.', false);
		}
	}


	function displaySuccessMessage(message) {
		const successBox = document.getElementById("successBox");
		successBox.textContent = message;
		successBox.style.top = "10px";
		successBox.style.opacity = "1";

		setTimeout(() => {
			successBox.style.top = "-50px";
			successBox.style.opacity = "0";
		}, 3000); // Oculta a mensagem após 3 segundos
	}

	function logout() {
		userIsLoggedIn = false; // Altere o estado do usuário para deslogado
		
		document.getElementById('sendDataButton').style.display = 'none'; // Oculta o botão de enviar dados

		let title = "";
		if(!user.instancePrepositionJurisdictionUUID.includes("WorkerUUID")){
			if (user.pronoun === 'feminino') {
				title = 'Conselheira';
			} else if (user.pronoun === 'masculino') {
				title = 'Conselheiro';
			} else {
				title = 'Conselheire';
			}
		}

		showNotification(`Até a próxima, ${title} ${user.name}!`, true); // Mensagem de confirmação
		
		// Limpar os campos do formulário
		document.getElementById('username').value = '';
		document.getElementById('password').value = '';
		document.getElementById('instance').value = '';
		document.getElementById('pronoun').value = '';
		document.getElementById('jurisdiction').value = '';
		document.getElementById('preposition').value = '';
		document.getElementById('nameRegistration').value = '';
		document.getElementById('uuidQRCode').innerHTML = '';
		clearTable();
		user = null;
		
		updateInfoBar(); // Atualiza a barra de informações para refletir o estado de logout
		
		// Rola suavemente para o topo da página
		window.scrollTo({
			top: 0,
			behavior: 'smooth',
		});
		
		// Esconde a div "logado"
		document.getElementById('logado').style.display = 'none'; // Torna invisível
		
		 // Remove a classe 'logged-in' do #globeContainer para voltar ao alinhamento centralizado
		const globeContainer = document.getElementById('globeContainer');
		globeContainer.classList.remove('logged-in'); // Remove a classe para voltar ao centro
		
	}

	function showNotification(message, isSuccess) {
		const notificationBox = document.getElementById('successBox');
		notificationBox.textContent = message; // Define a mensagem
		notificationBox.style.opacity = '1'; // Torna visível
		notificationBox.style.top = '10px'; // Move para uma posição visível

		// Ajusta a cor de fundo com base no tipo de mensagem
		if (isSuccess) {
			notificationBox.style.backgroundColor = 'rgba(0, 255, 0, 0.8)'; // Verde para mensagens de sucesso
			notificationBox.style.color = 'rgba(255, 255, 255, 1)'; // Verde para mensagens de sucesso
		} else {
			notificationBox.style.backgroundColor = 'rgba(255, 255, 0, 0.8)'; // Amarelo amarronzado para mensagens de erro/atenção
			notificationBox.style.color = 'rgba(70, 0, 0, 1)'; // Verde para mensagens de sucesso
		}

		 // Calcula a duração da mensagem com base no tamanho do texto
		const duration = Math.ceil(message.length / 80) * 3000;

		// Oculta a mensagem após o tempo calculado
		setTimeout(() => {
			notificationBox.style.opacity = '0'; // Torna invisível
			notificationBox.style.top = '-50px'; // Move para fora da tela
		}, duration);
	}

	// Manipulador para pressionar "Enter" nos campos de Login ou Cadastre-se
	document.addEventListener('keydown', function(event) {
		if (event.key === 'Enter') {
			const activeElement = document.activeElement; // Elemento que está em foco
			const loginSection = document.getElementById('loginSection');
			const registerFields = document.getElementById('registrationFields');

			// Verifica se a seção de Login está visível
			if (loginSection && loginSection.style.display !== 'none') {
				// Caso esteja no modo de Cadastro
				if (registerFields && registerFields.style.display === 'block') {
					// Verifica se o foco está em um dos campos de Cadastro
					if (activeElement.id === 'instance' || 
						activeElement.id === 'pronoun' || 
						activeElement.id === 'jurisdiction' || 
						activeElement.id === 'preposition') {
						event.preventDefault(); // Impede o comportamento padrão do Enter
						handleRegister(); // Simula o clique no botão "Cadastrar"
						return;
					}
				}

				// Verifica se o foco está nos campos de Nome de Usuário ou Senha
				if (activeElement.id === 'username' || activeElement.id === 'password') {
					event.preventDefault(); // Impede o comportamento padrão do Enter
					//document.getElementById('loginButton').click(); // Simula o clique no botão "Entrar"
					handleLogin();
				}
			}
		}
	});

	let marker, camera, label; // Declare as variáveis no escopo global

	function initSmallGlobe() {
		// Seleciona o contêiner para a animação
		const globeContainer = document.getElementById('globeContainer');

		// Configurações iniciais da cena
		const scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
		const renderer = new THREE.WebGLRenderer({ alpha: true }); // Fundo transparente
		renderer.setSize(300, 300); // Tamanho fixo do globo
		globeContainer.appendChild(renderer.domElement);

		 // Adiciona a esfera da Terra
		const textureLoader = new THREE.TextureLoader();
		const earthTexture = textureLoader.load('https://i.postimg.cc/90NWNd6t/textura-Terra.jpg');
		
		
		const earthGeometry = new THREE.SphereGeometry(1, 32, 32);
		const earthMaterial = new THREE.MeshStandardMaterial({ map: earthTexture });
		earthMaterial.transparent = true;
		earthMaterial.opacity = 0.8;
		const earth = new THREE.Mesh(earthGeometry, earthMaterial);

		// Corrige a orientação da textura
		//earth.rotation.x = Math.PI; // Gira 180 graus para alinhar corretamente


		// Ajuste manual da rotação
		//earth.rotation.y = THREE.MathUtils.degToRad(80); // Corrigir longitude

		scene.add(earth);

		// Adiciona iluminação
		const ambientLight = new THREE.AmbientLight(0xff0000, 2);
		scene.add(ambientLight);

		// Aqui adicionamos a luz vermelha
		const redLight = new THREE.PointLight(0xffbbbb, 1);
		redLight.position.set(50, 30, 50);
		scene.add(redLight);

		// Configura a posição inicial da câmera
		camera.position.z = 3;

		// Adiciona o marcador vermelho para a localização do usuário
		navigator.geolocation.getCurrentPosition(function (position) {
			const latitude = position.coords.latitude;
			const longitude = position.coords.longitude;

			let ajusteManualDeLongitude = -99; //Ajuste para calibração da Longitude do Marcador, em graus

			// Converter latitude e longitude para coordenadas 3D
			const phi = (90 - latitude) * (Math.PI / 180); // Latitude
			const theta = (longitude + 180 + ajusteManualDeLongitude) * (Math.PI / 180); // Longitude

	const loader = new THREE.TextureLoader();
	const globeRadius = 1; // Substitua pelo raio real do globo (exemplo: 1 para THREE.SphereGeometry(1, ...))
	const displacement = 0.1; // Ajuste o deslocamento para fora do globo

	loader.load('https://i.postimg.cc/65gr9cjN/bandeiravermelhaanimada.gif', function (texture) {
		// Criar a geometria da bandeira (um plano)
		const planeGeometry = new THREE.PlaneGeometry(0.2, 0.2); // Ajuste o tamanho da bandeira
		const planeMaterial = new THREE.MeshBasicMaterial({
			map: texture,
			transparent: true,
			side: THREE.DoubleSide // Garante que a bandeira seja visível dos dois lados
		});
		marker = new THREE.Mesh(planeGeometry, planeMaterial); // Armazena na variável global

		// Posicionar a bandeira fora do globo
		marker.position.set(
			(Math.sin(phi) * Math.cos(theta)) * (globeRadius + displacement),
			(Math.cos(phi)) * (globeRadius + displacement),
			(Math.sin(phi) * Math.sin(theta)) * (globeRadius + displacement)
		);

		// Vetor que aponta para o centro do globo
		const center = new THREE.Vector3(0, 0, 0);
		const directionToCenter = center.clone().sub(marker.position).normalize();

		// Alinhar a bandeira com a superfície
		const upVector = new THREE.Vector3(0, -1, 0); // Vetor "para cima" da bandeira
		const quaternion = new THREE.Quaternion().setFromUnitVectors(upVector, directionToCenter);
		marker.setRotationFromQuaternion(quaternion);
		

		// Adicionar a bandeira ao globo
		earth.add(marker);
	});





			// Usar a API de Geocodificação Reversa para obter o nome da cidade
			const geocodeUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&addressdetails=1&zoom=18`;

			fetch(geocodeUrl)
				.then(response => response.json())
				.then(data => {
					// Tenta diferentes campos para o nome da cidade
					const city = data.address.city || data.address.town || data.address.village || "Cidade desconhecida";
					const state = data.address.state || data.address.region;
					const country = data.address.country;

					// Criar um rótulo HTML para a localização no globo
					label = document.createElement('div');
					label.innerHTML = `${city}, <br>${state}, <br>${country}`;
					label.style.position = 'absolute';
					label.style.fontSize = '12px';
					label.style.fontWeight = 'bold';
					label.style.backgroundColor = 'rgba(255, 255, 255, 0.7)'; // Fundo branco transparente
					label.style.color = '#8B0000'; // Texto vermelho escuro
					label.style.padding = '5px 10px'; // Espaçamento interno
					label.style.borderRadius = '5px'; // Bordas arredondadas
					label.style.textAlign = 'center'; // Centraliza o texto horizontalmente
					label.style.pointerEvents = 'none'; // Evita que o rótulo interfira com interações do globo
					label.style.transform = 'translateX(-50%)'; // Centraliza o rótulo

					// Posicionar o rótulo em cima do ponteiro (marcador)
					globeContainer.appendChild(label);
					
					globeContainer.style.visibility = 'visible';
					
					// Função para atualizar a posição do rótulo com base na rotação
					function updateLabelPosition() {
						const vector = new THREE.Vector3();
						const canvasBounds = renderer.domElement.getBoundingClientRect();

						// Posição da bandeira no mundo 3D
						vector.setFromMatrixPosition(marker.matrixWorld);

						// Converte a posição 3D para 2D (tela)
						vector.project(camera);

						// Converte para coordenadas de pixel no canvas
						const x = (vector.x * 0.5 + 0.5) * canvasBounds.width;
						const y = (1 - (vector.y * 0.5 + 0.5)) * canvasBounds.height;

						// Posiciona o rótulo acima da bandeira (ajuste "y" para subir um pouco)
						label.style.left = `${x}px`;
						label.style.top = `${y - 100}px`; // Move o rótulo um pouco para cima
						
						//console.info('vector.z'+vector.z);
						
						if (vector.z < 0.94) {
							label.style.display = 'block'; // Mostra o HTML quando a bandeira está à frente
						} else {
							label.style.display = 'none'; // Oculta o HTML quando a bandeira está atrás
						}
						
					}

					// Função para converter coordenadas 3D para coordenadas da tela
					function getScreenPosition(position, camera, renderer) {
						const vector = position.clone().project(camera);
						const x = (vector.x * 0.5 + 0.5) * renderer.domElement.width;
						const y = (vector.y * -0.5 + 0.5) * renderer.domElement.height;
						return { x, y };
					}

					// Atualiza a posição do rótulo durante a animação
					function animate() {
						requestAnimationFrame(animate);
						 // Atualize a posição do rótulo
						updateLabelPosition();
					}

					animate();
				})
				.catch(error => {
					console.error('Erro ao obter o nome da cidade:', error);
				});
		}, function (error) {
			console.error('Erro ao obter localização:', error);
		});

		// Função de animação
		function animate() {
			requestAnimationFrame(animate);
			earth.rotation.y += 0.001; // Velocidade de rotação
			
			renderer.render(scene, camera);
		}

		animate();
	}

	function fillTableWithData(inputTableData) {
		const tbody = document.querySelector('#inputTable tbody');
		const thead = document.querySelector('#inputTable thead tr');

		// Limpa a tabela existente
		tbody.innerHTML = '';
		thead.innerHTML = '<th>Produtos / Setores Produtivos</th>';

		if (inputTableData.length === 0) {
			showNotification("Tabela vazia recebida, nenhuma alteração feita.", false);
			return;
		}

		// Atualiza os cabeçalhos da tabela com base no número de colunas
		const numCols = inputTableData[0].length;
		for (let j = 0; j < numCols; j++) {
			const sectorHeader = document.createElement('th');
			const sectorInput = document.createElement('input');
			sectorInput.type = 'text';
			sectorInput.value = `Setor ${j + 1}`;
			sectorInput.oninput = () => updateSectorName(j, sectorInput.value);
			sectorInput.readOnly = true;
			addTooltipBehavior(sectorInput); // Adiciona o comportamento de tooltip
			sectorHeader.appendChild(sectorInput);
			thead.appendChild(sectorHeader);
		}

		// Preenche a tabela com os dados recebidos
		inputTableData.forEach((row, rowIndex) => {
			const tableRow = document.createElement('tr');

			// Adiciona uma célula para o nome do produto
			const productNameCell = document.createElement('td');
			const productInput = document.createElement('input');
			productInput.type = 'text';
			productInput.value = `Produto ${rowIndex + 1}`;
			productInput.oninput = () => updateProductName(rowIndex, productInput.value);
			productNameCell.appendChild(productInput);
			tableRow.appendChild(productNameCell);

			// Preenche os valores das colunas
			row.forEach(value => {
				const cell = document.createElement('td');
				const input = document.createElement('input');
				input.type = 'number';
				input.value = value || 0;
				cell.appendChild(input);
				addHighlightBehavior(cell); // Adiciona o comportamento de destaque
				tableRow.appendChild(cell);
			});

			tbody.appendChild(tableRow);
		});

		//showNotification("Tabela preenchida com os dados recebidos.", true);
	}


	function setFinalDemand(finalDemandData) {
		const tbody = document.getElementById('finalDemandInputs');
		const rows = tbody.querySelectorAll('tr');

		// Certifica-se de que o número de entradas de demanda corresponda ao número de linhas
		rows.forEach((row, index) => {
			const input = row.querySelector('input[type="number"]');
			input.value = finalDemandData[index] !== undefined ? finalDemandData[index] : 0;
		});

		showNotification("Demanda final atualizada com os dados recebidos.", true);
	}

	function synchronizeFinalDemandProducts() {
		const productRows = document.querySelectorAll('#inputTable tbody tr');
		const demandRows = document.querySelectorAll('#finalDemandInputs tr');

		productRows.forEach((productRow, index) => {
			const productName = productRow.querySelector('td:first-child input').value;
			if (demandRows[index]) {
				demandRows[index].querySelector('td:first-child').textContent = productName;
			}
		});
	}

	function updateAllOptimizeButtons() {
		const demandRows = document.querySelectorAll('#finalDemandInputs tr');
		
		demandRows.forEach((row, index) => {
			updateOptimizeButtonColor(index); // Atualiza a cor do botão com base nos novos dados
		});
	}

	function toggleHTMLVisibility(htmlElement, object, camera) {
		const vector = new THREE.Vector3();
		object.getWorldPosition(vector); // Obtém a posição da bandeira no mundo
		vector.project(camera); // Projeta a posição para a tela

		if (vector.z > 0) {
			htmlElement.style.display = 'block'; // Mostra o HTML quando a bandeira está à frente
		} else {
			htmlElement.style.display = 'none'; // Oculta o HTML quando a bandeira está atrás
		}
	}

	function updateVetorTecnologicoTable() {
		const quantidadeBensProducao = parseInt(document.getElementById('quantidadeBensProducao').value, 10);
		const table = document.getElementById('vetorTecnologicoTable');
		const tbody = table.querySelector('tbody');
		const productColumnTitle = document.querySelector('#producaoMetaTable tbody tr td:first-child input').value;

		// Salvar os dados antigos da tabela "Vetor Tecnológico"
		const previousData = [];
		tbody.querySelectorAll('tr').forEach((row, rowIndex) => {
			const rowData = [];
			row.querySelectorAll('td input').forEach((input, colIndex) => {
				rowData[colIndex] = input.value; // Armazena o valor da célula
			});
			previousData[rowIndex] = rowData;
		});
		

		// Limpar o conteúdo atual da tabela
		tbody.innerHTML = '';

		// Criar novas linhas preservando dados antigos
		for (let i = 0; i < quantidadeBensProducao; i++) {
			const row = document.createElement('tr');

			// Criar célula do nome do bem de produção
			const productCell = document.createElement('td');
			const productInput = document.createElement('input');
			productInput.type = 'text';
			productInput.value = previousData[i] && previousData[i][0] !== undefined ? previousData[i][0] : `Bem ${i + 1}`;
			productInput.oninput = syncProductionNames; // Atualiza nomes automaticamente
			productCell.appendChild(productInput);
			row.appendChild(productCell);

			// Criar célula do valor tecnológico
			const valueCell = document.createElement('td');
			const valueInput = document.createElement('input');
			valueInput.type = 'number';
			valueInput.value = previousData[i] && previousData[i][1] !== undefined && previousData[i][1] !== ''
				? previousData[i][1]
				: '0'; // Define vazio se não houver valor anterior
			valueCell.appendChild(valueInput);
			row.appendChild(valueCell);

			tbody.appendChild(row);
		}

		// Atualizar a tabela de estoque e demanda preservando dados
		updateEstoqueDemandaTable(quantidadeBensProducao);
		syncProductionNames(); // Sincroniza os nomes iniciais
		
		document.querySelector('#vetorTecnologicoTable thead tr th:nth-child(2)').innerHTML = `Quantidade necessária para produzir 1 unidade de ${productColumnTitle}`;
		
	}



	function updateEstoqueDemandaTable(quantidadeBensProducao) {
		const tableBody = document.querySelector("#estoqueDemandaTable tbody");

		// Salvar os dados existentes antes de limpar a tabela
		const previousData = Array.from(tableBody.querySelectorAll("tr")).map(row => ({
			bemDeProducao: row.cells[0].textContent.trim(),
			estoque: row.cells[1].querySelector("input").value.trim(),
			demanda: row.cells[2].querySelector("input").value.trim()
		}));

		// Limpar a tabela
		tableBody.innerHTML = '';

		// Criar novas linhas preservando dados antigos
		for (let i = 0; i < quantidadeBensProducao; i++) {
			const row = document.createElement('tr');

			// Coluna "Bem de Produção"
			const bemDeProducaoCell = document.createElement('td');
			bemDeProducaoCell.textContent = previousData[i]?.bemDeProducao || `Bem ${i + 1}`;
			row.appendChild(bemDeProducaoCell);

			// Coluna "Estoque"
			const estoqueCell = document.createElement('td');
			const estoqueInput = document.createElement('input');
			estoqueInput.type = 'number';
			estoqueInput.value = previousData[i]?.estoque || 0; // Mantém o valor ou define como 0
			estoqueCell.appendChild(estoqueInput);
			row.appendChild(estoqueCell);

			// Coluna "Demanda"
			const demandaCell = document.createElement('td');
			const demandaInput = document.createElement('input');
			demandaInput.type = 'number';
			demandaInput.value = previousData[i]?.demanda || 0; // Mantém o valor ou define como 0
			demandaCell.appendChild(demandaInput);
			row.appendChild(demandaCell);

			tableBody.appendChild(row);
		}
	}


	function openPropostaModal(index, productName) {
		const modal = document.getElementById('propostaModal');
		const unitName = document.getElementById('comiteColTitle').value || 'Unidade de Produção';
		document.getElementById('unitName').textContent = unitName;
		modal.style.display = 'flex';
		setupEnterKeyListenerForPropostaModal(); // Adiciona o ouvinte
	}

	function closePropostaModal() {
		document.getElementById('propostaModal').style.display = 'none';
	}

	function syncProductionNames() {
		const vetorRows = document.querySelectorAll('#vetorTecnologicoTable tbody tr');
		const estoqueRows = document.querySelectorAll('#estoqueDemandaTable tbody tr');

		vetorRows.forEach((vetorRow, index) => {
			const productInput = vetorRow.querySelector('td:first-child input');
			const estoqueCell = estoqueRows[index]?.querySelector('td:first-child');

			if (productInput && estoqueCell) {
				estoqueCell.textContent = productInput.value; // Atualiza o nome
			}
		});
	}

	
	function openProducaoMetaModal() {
    // Obtém a referência ao modal
    const modal = document.getElementById('producaoMetaModal');

    // Variáveis locais para exibir no modal
    const unitName = document.getElementById('comiteColTitle')?.value || 'Nome não definido';
    const productName = document.querySelector('#producaoMetaTable tbody tr td:first-child input')?.value || 'Produto não definido';
    const workersLimit = document.getElementById('limiteEfetivoTrabalhadores')?.value || '0';
    const producedQuantity = document.getElementById('producedQuantity')?.value || '0';
    const pendingQuantity = document.getElementById('pendingProductionQuantity')?.value || '0';
    const conselhoAssociado = document.getElementById('conselhoPopularAssociadoDeComiteOuTrabalhador')?.value || null;

    // Verifica se o Conselho Associado está definido
    if (!conselhoAssociado) {
        //console.info('Conselho Associado não definido.');
        return;
    }

	//alert(`${councilData} ${currentProductIndex} ${modalContext}`);

	if(null !== councilData && null !== currentProductIndex && null !== modalContext){
		populateModalContent(councilData, currentProductIndex, modalContext);
		return;
	}

    // Carregar os dados diretamente do JSONBIN usando conselhoAssociado como instanceKey
    showNotification('Carregando informações do Conselho associado...', true);

    fetch(apiUrl, {
		method: 'GET',
		headers: headers
	})
		.then(response => response.json())
		.then(binData => {
            const record = binData || {};
            councilData = record[conselhoAssociado]; // Usa conselhoAssociado como instanceKey

            // Verifica se os dados do Conselho Associado estão disponíveis
            if (!councilData || !councilData.productNames) {
                showNotification('Dados do Conselho associado não encontrados.', false);
                return;
            }

            // Encontra o índice do produto no array productNames
            currentProductIndex = councilData.productNames.indexOf(productName);
            if (currentProductIndex === -1) {
                showNotification('Produto não encontrado no Conselho associado.', false);
                return;
            }

			modalContext = {
                unitName,
                productName,
                workersLimit,
                producedQuantity,
                pendingQuantity
            };

            populateModalContent(councilData, currentProductIndex, modalContext);
        })
        .catch(err => {
            console.error('Erro ao buscar dados do JSONBin:', err);
            showNotification('Erro ao buscar dados do Conselho associado.', false);
        });
}

function populateModalContent(councilData, currentProductIndex, modalContext) {
	
	// Obtém os dados específicos do produto
	const optimizationInputs = councilData.optimizationInputs[currentProductIndex] || {};
	const optimizationResults = councilData.optimizationResults[currentProductIndex] || {};
	
    // Desestrutura o contexto para facilitar o acesso
    const { unitName, productName, workersLimit, producedQuantity, pendingQuantity } = modalContext;

    // Dados específicos do produto
    const workerHours = optimizationInputs.workerHours || 'Não definido';
    const weeklyScale = optimizationInputs.weeklyScale;
	const daysOff = 7 - weeklyScale; // Dias de folga na semana
	const formattedWeeklyScale = `${weeklyScale}X${daysOff}`; // Formata como solicitado
    const nightShift = optimizationInputs.nightShift ? 'Diurno e Noturno' : 'Diurno';
    const productionTime = optimizationInputs.productionTime || 0;
    const totalEmploymentPeriod = formatDays(parseFloat(optimizationResults.totalEmploymentPeriod) * 24); // Converte dias em horas para formatDays
	
	//console.info("optimizationInputs: ");
	//console.log(optimizationInputs);
	
	effectivelyPlannedProductionTime = productionTime; //para ser salvo e usado depois usado no calculo do trabalho social total. é pego já planificado a partir do conselho acima que fez o calculo de planificação

    // Atualiza o conteúdo do modal
    document.getElementById('producaoMetaContent').innerHTML = `
        <p><strong>Nome da Unidade de Produção:</strong> ${unitName}</p>
        <p><strong>Produto:</strong> ${productName}</p>
        <p><strong>Expediente:</strong> ${workerHours} horas</p>
        <p><strong>Escala Semanal:</strong> ${formattedWeeklyScale}</p>
        <p><strong>Quantidade Necessária de Trabalhadores:</strong> ${workersLimit}</p>
        <p><strong>Produção Finalizada:</strong> ${producedQuantity}</p>
        <p><strong>Produção Pendente:</strong> ${pendingQuantity}</p>
        <p><strong>Turno:</strong> ${nightShift}</p>
        <p><strong>Tempo para Produção (para contratação ou renovação):</strong> ${totalEmploymentPeriod}</p>
    `;
    document.getElementById('producaoMetaModal').style.display = 'flex';
}



	
	function closeProducaoMetaModal() {
		const modal = document.getElementById('producaoMetaModal');
		modal.style.display = 'none';
	}

	function scrollToEndOfPage() {
		window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
	}

	// Função para fechar qualquer modal aberto
	function closeAllModals() {
		const modals = document.querySelectorAll('.modal'); // Seleciona todos os modais
		modals.forEach(modal => {
			modal.style.display = 'none';
		});
	}

	// Evento para fechar o modal ao clicar fora do conteúdo
	window.addEventListener('click', (event) => {
		const modals = document.querySelectorAll('.modal');
		modals.forEach(modal => {
			if (event.target === modal) { // Verifica se o clique foi fora do modal
				modal.style.display = 'none';
			}
		});
		
		const menu = document.getElementById('languageMenu');
        const button = document.getElementById('languageButton');
        if (!menu.contains(event.target) && event.target !== button) {
            menu.style.display = 'none';
        }
		
	});

	 // Manipula a rolagem para criar o efeito de parallax
	 let currentOffset = 0; // Posição atual suavizada
		let targetOffset = 0;  // Posição alvo

		const lerp = (start, end, t) => start + (end - start) * t; // Função de interpolação linear

		const updateBackground = () => {
			// Aproxima a posição atual da posição alvo com suavidade
			currentOffset = lerp(currentOffset, targetOffset, 0.05);

			// Define a posição do fundo
			document.body.style.setProperty('--background-offset', `${currentOffset}%`);

			// Continua o loop
			requestAnimationFrame(updateBackground);
		};

		// Atualiza a posição alvo com base na rolagem do usuário
		window.addEventListener('scroll', () => {
			const scrollPosition = window.scrollY;
			const maxScroll = document.body.scrollHeight - window.innerHeight;

			// Calcula o deslocamento desejado para a imagem de fundo
			targetOffset = (scrollPosition / maxScroll) * 100;
		});

		// Inicia o loop de atualização do plano de fundo
		updateBackground();

	function savePropostaInputs() {
		const workerLimit = document.getElementById("workerLimitProposta").value.trim();
		const workerHours = document.getElementById("workerHoursProposta").value.trim();
		const productionTime = document.getElementById("productionTimeProposta").value.trim();
		const nightShift = document.getElementById("nightShiftProposta").checked;
		const weeklyScale = document.getElementById("weeklyScaleProposta").value.trim();

		propostaDados = {
			workerLimit,
			workerHours,
			productionTime,
			nightShift,
			weeklyScale
		};

		closePropostaModal();
	}

	// Atualiza o título da coluna na tabela "Vetor Tecnológico"
	function atualizarTituloColunaVetorTecnologico() {
		const produtoInput = document.querySelector('#producaoMetaTable tbody tr td:first-child input');
		const produtoNome = produtoInput.value || "Produto";
		const colunaTitulo = document.querySelector('#vetorTecnologicoTable thead tr th:nth-child(2)');
		if (colunaTitulo) {
			colunaTitulo.innerHTML = `Quantidade necessária para produzir 1 unidade de ${produtoNome}`;
		}
	}

	// Função para lidar com a tecla Enter no modal "Proposta para demais Trabalhadores"
	function setupEnterKeyListenerForPropostaModal() {
		const modal = document.getElementById("propostaModal");

		// Adiciona o ouvinte ao modal
		modal.addEventListener("keydown", (event) => {
			if (event.key === "Enter") {
				event.preventDefault(); // Impede o comportamento padrão do Enter
				savePropostaInputs(); // Chama a função de salvar
			}
		});
	}

	//COLOCAR AQUI NESSA FUNÇÃO TRECHO QUE, SEJA O CONSELHO QUE FOR, SOMA A CADA SUB-CONSELHO (COMEÇANDO DE ZERO) O TRABALHO SOCIAL TOTAL REALIZADO, ASSIM NO CONSELHO MUNDIAL, AO EXECUTAR ESSA FUNÇÃO, JÁ TEM SEMPRE O VALOR DO TRABALHO SOCIAL TOTAL ATUALIZADO. COMO CONSEGUE O TRABALHO TOTAL REALIZADO DE UM CONSELHO? VEM DE QUAL ATRIBUTO?
	async function fetchEstimates() {
		
	if (!confirm("Alguns dados da Matriz Tecnológica atual serão perdidos e substituídos por dados da estimativa calculada. Tem certeza que deseja prosseguir?")) {
		return; // Sai da função se o usuário desistir
	}
		
    try {
        const response = await fetch(apiUrl, {
			method: 'GET',
			headers: headers
		});


        if (!response.ok) {
            throw new Error("Erro ao buscar dados do JSONBIN.");
        }

        const data = await response.json();

// Adição para processar matrizes tecnológicas dos Conselhos acima do Distrital
if (!user.instancePrepositionJurisdictionUUID.includes("Distrital") && !user.instancePrepositionJurisdictionUUID.includes("Comitê")) {
    const recordsArray = Object.values(data);
    const relevantMatrices = recordsArray.filter(item => 
        item.conselhoPopularAssociadoDeConselhoPopular === user.instancePrepositionJurisdictionUUID &&
        item.inputTable
    );
	
	

    if (relevantMatrices.length > 0) {
        const productSet = new Set();
        const averagedMatrix = {};
        const demandVector = {};
        const optimizationInputs = []; // Array para armazenar os dados para cada produto

        // Lista todos os produtos sem redundância e também calcula o trabalho social total em conselhos supradistritais
        relevantMatrices.forEach(matrix => {
            matrix.productNames.forEach(productName => productSet.add(productName)); //productSet acaba com a redundância que existe aqui nessa iteração

			//Soma o Trabalho Social Total da jurisdição do respectivo Conselho Supradistrital (não Comitês nem Conselhos Distritais, que já está feito e calculando corretamente). Serve para todos os supradistritais até o Conselho Mundial
			totalSocialWorkDessaJurisdicao += matrix.totalSocialWorkDessaJurisdicao;
			
			console.info("totalSocialWorkDessaJurisdicao += matrix.totalSocialWorkDessaJurisdicao;");
			console.log(totalSocialWorkDessaJurisdicao);
			
        });

        const productList = Array.from(productSet); // Lista ordenada de produtos

        // Calcula médias para cada combinação de produto e setor
        productList.forEach((productName, productIndex) => {
            relevantMatrices.forEach(matrix => {
                const matrixProductIndex = matrix.productNames.indexOf(productName);
				
				if (matrixProductIndex !== -1) {
				
                    // Cálculo da matriz tecnológica
                    matrix.inputTable[matrixProductIndex].forEach((value, sectorIndex) => {
                        const sectorName = `Produção de ${matrix.productNames[sectorIndex]}`;
                        const key = `${productName}:${sectorName}`;
                        if (!averagedMatrix[key]) {
                            averagedMatrix[key] = { sum: 0, count: 0 };
                        }
                        if (value !== undefined && value !== null) {
							
							//alert("averagedMatrix[key].sum += parseFloat(value);");
							//ENTROU. CADA CONSELHO FAZER SUA SOMA COM BASE NA VARIAVEL DOS CONSELHOS ABAIXO (SO SOMAR TUDO QUE VEM DE BAIXO, 1 VEZ POR CONSELHO (IF SE CONSELHO É DIFERENTE DO ANTERIOR, PRA VER SE JA MUDOU) E COLOCAR NA VARIAVEL
							//OPTIMIZATIONINPUTS[PRODUCTINDEX] DO CONSELHO (DATA. OU MATRIX. OU ALGO DO TIPO QUE CARREGOU NESSA ITERAÇÃO, MAS ANTES CARREGAVA SO COMITE, VE SE CARREGA CONSELHO COM CONSELHOASSOCIADODECONSELHO IGUAL AO DO USUARIO ATUAL) MULTIPLICADO PELO QUE JÁ FOI PRODUZIDO ATÉ ESSA JURISDIÇÃO
							
							//console.info("matrix: ");
							//console.log(matrix);
							
                            averagedMatrix[key].sum += parseFloat(value);
                            averagedMatrix[key].count += 1;
                        }
                    });

                    // Cálculo do vetor de demanda
                    const demandValue = matrix.finalDemand[matrixProductIndex];
                    if (!demandVector[productName]) {
                        demandVector[productName] = { sum: 0, count: 0 };
                    }
                    if (demandValue !== undefined && demandValue !== null) {
						
						//alert("demandVector[productName].sum += parseFloat(demandValue);");
						//ENTROU. CADA CONSELHO FAZER SUA SOMA COM BASE NA VARIAVEL DOS CONSELHOS ABAIXO (SO SOMAR TUDO QUE VEM DE BAIXO, 1 VEZ POR CONSELHO (IF SE CONSELHO É DIFERENTE DO ANTERIOR, PRA VER SE JA MUDOU) E COLOCAR NA VARIAVEL
						//OPTIMIZATIONINPUTS[PRODUCTINDEX] DO CONSELHO (DATA. OU MATRIX. OU ALGO DO TIPO QUE CARREGOU NESSA ITERAÇÃO, MAS ANTES CARREGAVA SO COMITE, VE SE CARREGA CONSELHO COM CONSELHOASSOCIADODECONSELHO IGUAL AO DO USUARIO ATUAL) MULTIPLICADO PELO QUE JÁ FOI PRODUZIDO ATÉ ESSA JURISDIÇÃO
						
						//Entra quando é Comitê ou Conselho
						//totalSocialWorkDessaJurisdicao já está calculado certo e salvo nos conselhos distritais abaixo
						
                        demandVector[productName].sum += parseFloat(demandValue);
                        demandVector[productName].count += 1;						
					}
				}
			});

            // Inicializa os campos para cálculo das médias dos campos exibidos na janela modal
            let totalWorkerLimit = 0, countWorkerLimit = 0;
            let totalWorkerHours = 0, countWorkerHours = 0;
            let totalProductionTime = 0, countProductionTime = 0;
            let totalWeeklyScale = 0, countWeeklyScale = 0;
			let totalNightShift = 0, countNightShift = 0;

            // Calcula as médias para os campos exibidos na janela modal
            relevantMatrices.forEach(matrix => {
                let matrixProductIndex = matrix.productNames.indexOf(productName);

				//console.info("matrixProductIndex: ");
				//console.log(matrixProductIndex);

                if (matrixProductIndex !== -1) {

					//console.info("matrix: ");
					//console.log(matrix);

                    let workerLimit = matrix.optimizationInputs[matrixProductIndex]?.workerLimit;
                    let workerHours = matrix.optimizationInputs[matrixProductIndex]?.workerHours;
                    let productionTime = matrix.optimizationInputs[matrixProductIndex]?.productionTime;
                    let weeklyScale = matrix.optimizationInputs[matrixProductIndex]?.weeklyScale;
					let nightShift = Number(matrix.optimizationInputs[matrixProductIndex]?.nightShift);
					
					
					//console.info("workerLimit: ");
					//console.log(workerLimit);
					//console.info("workerHours: ");
					//console.log(workerHours);
					//console.info("productionTime: ");
					//console.log(productionTime);
					//console.info("weeklyScale: ");
					//console.log(weeklyScale);

                    if (workerLimit !== undefined && workerLimit !== null) {
                        totalWorkerLimit += parseFloat(workerLimit);
                        countWorkerLimit++;
                    }

                    if (workerHours !== undefined && workerHours !== null) {
                        totalWorkerHours += parseFloat(workerHours);
                        countWorkerHours++;
                    }

                    if (productionTime !== undefined && productionTime !== null) {
                        totalProductionTime += parseFloat(productionTime);
                        countProductionTime++;
                    }

                    if (weeklyScale !== undefined && weeklyScale !== null) {
                        totalWeeklyScale += parseFloat(weeklyScale);
                        countWeeklyScale++;
                    }
					
					 if (nightShift !== undefined && nightShift !== null) {
                        totalNightShift += parseFloat(nightShift);
                        countNightShift++;
                    }
                }
            });

            // Adiciona os valores calculados ao array de inputs de otimização
            optimizationInputs[productIndex] = {
                workerLimit: countWorkerLimit > 0 ? (totalWorkerLimit / countWorkerLimit).toFixed(2) : '',
                workerHours: countWorkerHours > 0 ? (totalWorkerHours / countWorkerHours).toFixed(2) : '',
                productionTime: countProductionTime > 0 ? (totalProductionTime / countProductionTime).toFixed(2) : '',
                weeklyScale: countWeeklyScale > 0 ? (totalWeeklyScale / countWeeklyScale).toFixed(2) : '',
				nightShift: countNightShift > 0 ? Boolean(Math.round((totalNightShift / countNightShift).toFixed(2))) : false,
            };
        });

        // Calcula os valores finais da matriz tecnológica
        Object.keys(averagedMatrix).forEach(key => {
            averagedMatrix[key] = averagedMatrix[key].count > 0
                ? averagedMatrix[key].sum / averagedMatrix[key].count
                : 0; // Preenche com 0 se não houver dados
        });

        // Calcula os valores finais do vetor de demanda
        Object.keys(demandVector).forEach(key => {
            demandVector[key] = demandVector[key].count > 0
                ? demandVector[key].sum / demandVector[key].count
                : 0; // Preenche com 0 se não houver dados
        });

        // Atualiza a tabela de matriz tecnológica
        const inputTable = document.getElementById('inputTable');
        const thead = inputTable.querySelector('thead');
        const tbody = inputTable.querySelector('tbody');

        // Cria cabeçalho com base na lista de produtos
        thead.innerHTML = '<tr><th>Produtos / Setores Produtivos</th></tr>';
        productList.forEach((productName, index) => {
            const sectorHeader = document.createElement('th');
            const sectorInput = document.createElement('input');
            sectorInput.type = 'text';
            sectorInput.value = `Produção de ${productName}`;
            sectorInput.readOnly = true;
            addTooltipBehavior(sectorInput); // Adiciona o comportamento de tooltip
            sectorHeader.appendChild(sectorInput);
            thead.querySelector('tr').appendChild(sectorHeader);
        });

        // Preenche linhas e células com os valores consolidados
        tbody.innerHTML = '';
        productList.forEach((productName, rowIndex) => {
            const row = document.createElement('tr');

            // Primeira célula: nome do produto com funcionalidade de edição
            const productCell = document.createElement('td');
            const productInput = document.createElement('input');
            productInput.type = 'text';
            productInput.value = productName;

            // Sincroniza o nome do produto com o título do setor
            productInput.oninput = () => {
                const correspondingHeader = thead.querySelectorAll('th')[rowIndex + 1]; // +1 para ignorar a coluna de produtos
                if (correspondingHeader) {
                    const headerInput = correspondingHeader.querySelector('input');
                    headerInput.value = `Produção de ${productInput.value}`;
                }
            };

            // Ajusta o cursor para o final do texto
            productInput.addEventListener('focus', () => {
                productInput.setSelectionRange(productInput.value.length, productInput.value.length);
            });

            productCell.appendChild(productInput);
            row.appendChild(productCell);

            // Outras células: valores médios ou "0"
            productList.forEach(targetProductName => {
                const cell = document.createElement('td');
                const input = document.createElement('input');
                input.type = 'number';
                input.readOnly = true;

                const key = `${productName}:Produção de ${targetProductName}`;
                input.value = averagedMatrix[key] !== undefined ? averagedMatrix[key].toFixed(2) : 0;
                cell.appendChild(input);
                addHighlightBehavior(cell); // Adiciona o comportamento de destaque
                row.appendChild(cell);
            });

            tbody.appendChild(row);
        });

		// Atualiza os valores de "Número de produtos" e "Número de Setores Produtivos"
		const numRows = document.getElementById('numRows'); // Campo "Número de produtos"
		const numCols = document.getElementById('numCols'); // Campo "Número de Setores Produtivos"

		// Obtém o número de linhas (produtos) e colunas (setores) da tabela "Matriz Tecnológica"
		const numProducts = tbody.querySelectorAll('tr').length; // Número de linhas
		const numSectors = thead.querySelector('tr').querySelectorAll('th').length - 1; // Número de colunas, excluindo a coluna "Produtos / Setores Produtivos"

		// Atualiza os campos com os valores calculados
		if (numRows) numRows.value = numProducts;
		if (numCols) numCols.value = numSectors;

        // Atualiza a tabela de demanda final com botões "Otimizar"
        const demandTableBody = document.getElementById('finalDemandInputs');
        demandTableBody.innerHTML = '';
        productList.forEach((productName, index) => {
            const row = document.createElement('tr');

            // Primeira célula: nome do produto
            const productCell = document.createElement('td');
            productCell.textContent = productName;
            row.appendChild(productCell);

            // Segunda célula: valor de demanda
            const demandCell = document.createElement('td');
            const demandInput = document.createElement('input');
            demandInput.type = 'number';
            demandInput.readOnly = true;
            demandInput.value = demandVector[productName] !== undefined ? demandVector[productName].toFixed(2) : 0;
            demandCell.appendChild(demandInput);
            row.appendChild(demandCell);

            // Terceira célula: Botão "Otimizar"
            const actionsCell = document.createElement('td');
            const optimizeButton = document.createElement('button');
            optimizeButton.textContent = 'Otimizar';
            optimizeButton.classList.add('optimize-button');
			//console.info("optimizationInputs: ");
			//console.log(optimizationInputs);
            optimizeButton.onclick = () => openOptimizationModalEstimates(index, optimizationInputs);
            actionsCell.appendChild(optimizeButton);
            row.appendChild(actionsCell);

            // Adiciona a linha à tabela
            demandTableBody.appendChild(row);
        });
    } else {
        showNotification("Nenhuma matriz tecnológica encontrada para os Conselhos abaixo do seu.", false);
    }
}
// Fim da adição


        if (typeof data === 'object' && data !== null) {
            const inputTechnologicalMatrixTableBody = document.getElementById('inputTechnologicalMatrixTableBody');
            Array.from(inputTechnologicalMatrixTableBody.rows).forEach(row => { //Iteração das linhas da matriz tecnológica
                let productName = row.cells[0].querySelector('input')?.value.trim() || '';

                const recordsArray = Object.values(data);

                let setorUnidade;
				
				if (productName.includes("Rede")) {
					setorUnidade = productName;
				} else {
					setorUnidade = `Produção de ${productName}`;
				}

				//toda vez que itera linha de matriz tecnológica itera as colunas pra achar a do produto atual que pertence ao vetor de demanda do comitê. filteredRecords é a lista de unidades de produção de cada setor que está sendo iterado. é a lista do setor iterado dessa vez.
                const filteredRecords = recordsArray.filter(item => 
                    item.conselhoPopularAssociadoDeComiteOuTrabalhador === user.instancePrepositionJurisdictionUUID && //QUANDO FOR CONSELHO CONSULTANDO CONSELHO USARÁ item.conselhoPopularAssociadoDeConselhoPopular
                    item.setorUnidade === setorUnidade
                );

                let resultMessage = "";
                let summedTechnologicalVectors = [];
				let summedDemandVectors = [];
				let summedProposalVectors = [];
                let workerLimit = null;

				//console.info("filteredRecords: ");
				//console.log(filteredRecords);

                if (filteredRecords.length > 0) {
                    resultMessage = `Vetores Tecnológicos do setor ${setorUnidade}:\n`;

                    const demandaFinalInputs = document.querySelectorAll('#finalDemandInputs input[type="number"]');
                    let productIndex = -1;

                    demandaFinalInputs.forEach((input, index) => {
                        const produtoNome = document.querySelectorAll('#finalDemandInputs tr')[index].cells[0].textContent.trim();
                        if (produtoNome === productName) { //Achando a coluna da matriz tecnológica que está o setor
                            productIndex = index;							
                        }
                    });

                    if (productIndex === -1) {
                        showNotification(`Cadastre o produto ${productName} nesse Conselho!`, false);
                        return;
                    }

					let limiteEfetivoTrabalhadoresTotal = 0;

					for (const productionUnit of filteredRecords) { //soma para achar o limiteEfetivoTrabalhadoresTotal necessário para o cálculo do peso.
						limiteEfetivoTrabalhadoresTotal = limiteEfetivoTrabalhadoresTotal + parseInt(productionUnit.limiteEfetivoTrabalhadores);
						
						console.info('productionUnit.effectivelyPlannedProductionTime: ');
						console.log(productionUnit.effectivelyPlannedProductionTime);
						
						//Só passa aqui quando é Comitê
						totalSocialWorkDessaJurisdicao += productionUnit.producaoMeta[0].quantidadeProduzida*productionUnit.effectivelyPlannedProductionTime;
						
				
					}
					
					//console.info("limiteEfetivoTrabalhadoresTotal: ");
					//console.log(limiteEfetivoTrabalhadoresTotal);
					
					console.info("totalSocialWorkDessaJurisdicao: ");
					console.log(totalSocialWorkDessaJurisdicao);

                    for (const productionUnit of filteredRecords) { //iteração das unidades de produção do setor desta rodada na iteração. o limiteEfetivoTrabalhadoresTotal deve ser somado antes, de todas essas unidades, antes de prosseguir, o que foi feito acima
						
						productionUnit.vetorDemanda = [];
						productionUnit.vetorProposta = [];
						if (Array.isArray(productionUnit.estoqueDemanda)) {
							 productionUnit.vetorDemanda = productionUnit.estoqueDemanda.map(item => item.demanda);
						}
						if (productionUnit.limiteEfetivoTrabalhadores !== undefined && productionUnit.propostaTrabalhadores) {
							productionUnit.vetorProposta = [
								productionUnit.limiteEfetivoTrabalhadores,
								productionUnit.propostaTrabalhadores.workerHours,
								productionUnit.propostaTrabalhadores.productionTime,
								Number(productionUnit.propostaTrabalhadores.nightShift), // transforma true e false em 1 e 0 pra poder calcular média e depois voltamos pra true e false arredondando pra 1 ou 0
								productionUnit.propostaTrabalhadores.weeklyScale
							];
						}
						
                        const vetorTecnologico = productionUnit.vetorTecnologico;
						const vetorDemanda = productionUnit.vetorDemanda;
						const vetorProposta = productionUnit.vetorProposta;
						
                        const limiteEfetivoTrabalhadores = parseFloat(productionUnit.limiteEfetivoTrabalhadores);

                        //if (optimizationInputs[productIndex] && optimizationInputs[productIndex].workerLimit) {
                        //    workerLimit = parseFloat(optimizationInputs[productIndex].workerLimit);
                        //}

                        //if (!workerLimit || isNaN(workerLimit)) {
                        //    showNotification(`Preencha os dados de otimização de ${productName}`, false);
                        //    openOptimizationModal(productIndex);
                        //    return;
                        //}

                        const productionUnitWeight = limiteEfetivoTrabalhadores / limiteEfetivoTrabalhadoresTotal;
						
						//console.info("limiteEfetivoTrabalhadores: ");
						//console.log(limiteEfetivoTrabalhadores);
						//console.info("limiteEfetivoTrabalhadores/limiteEfetivoTrabalhadoresTotal = productionUnitWeight: ");
						//console.log(productionUnitWeight);
						
                        const adjustedTechnologicalVectors = vetorTecnologico.map(value => (value * productionUnitWeight).toFixed(2));
						const adjustedDemandVectors = vetorDemanda.map(value => (value * productionUnitWeight).toFixed(2));
						const adjustedProposalVectors = vetorProposta.map(value => (value * productionUnitWeight).toFixed(2));
						adjustedProposalVectors[0]=limiteEfetivoTrabalhadoresTotal; //não calcula o peso do limiteEfetivoTrabalhadores, pois ele é real, efetivo, e é usado para o calculo do peso (não pode ser peso dele mesmo)

                        if (summedTechnologicalVectors.length === 0) {
                            summedTechnologicalVectors = adjustedTechnologicalVectors.map(val => parseFloat(val));
                        } else {
                            summedTechnologicalVectors = summedTechnologicalVectors.map((sum, i) => sum + parseFloat(adjustedTechnologicalVectors[i]));
                        }
						
						if (summedDemandVectors.length === 0) {
                            summedDemandVectors = adjustedDemandVectors.map(val => parseFloat(val));
                        } else {
                            summedDemandVectors = summedDemandVectors.map((sum, i) => sum + parseFloat(adjustedDemandVectors[i]));
                        }
						
						if (summedProposalVectors.length === 0) {
                            summedProposalVectors = adjustedProposalVectors.map(val => parseFloat(val));
                        } else {
                            summedProposalVectors = summedProposalVectors.map((sum, i) => sum + parseFloat(adjustedProposalVectors[i]));
                        }

                        resultMessage += `De alguma fábrica: ${vetorTecnologico.join(", ")}\n`;
                        resultMessage += `pesoDaUnidadeDeProdução=${productionUnitWeight.toFixed(2)}\n`;
                        resultMessage += `Vetor Tecnológico Médio: ${adjustedTechnologicalVectors.join(", ")}\n`;

                        const weightedAverageTechnologicalVector = summedTechnologicalVectors.map(sum => (sum / filteredRecords.length).toFixed(2));
                        resultMessage += `Média Ponderada dos Vetores Tecnológicos: ${weightedAverageTechnologicalVector.join(", ")}`;
						
						const weightedAverageDemandVector = summedDemandVectors.map(sum => (sum / filteredRecords.length).toFixed(2));
                        resultMessage += `Média Ponderada dos Vetores Demandas: ${weightedAverageDemandVector.join(", ")}`;
						
						const weightedAverageProposalVector = summedProposalVectors.map(sum => (sum / filteredRecords.length).toFixed(2));
						
						//Arredonda valores que não podem ser quebrados
						//weightedAverageProposalVector[0] = Math.round(weightedAverageProposalVector[0]); //limiteEfetivoTrabalhadores Total (não médio, senão não normaliza)
						
						//console.info("limiteEfetivoTrabalhadoresTotal: ");
						//console.log(limiteEfetivoTrabalhadoresTotal);
						
						
						
						weightedAverageProposalVector[0] = Math.round(limiteEfetivoTrabalhadoresTotal);
						weightedAverageProposalVector[1] = parseFloat(weightedAverageProposalVector[1]); //workerHours média
						weightedAverageProposalVector[2] = parseFloat(weightedAverageProposalVector[2]);
						weightedAverageProposalVector[3] = Boolean(Math.round(weightedAverageProposalVector[3])); //Turno Diurno/Noturno. se menor ou igual a 0,5 retorna false, se maior retorna true (média booleana)
						weightedAverageProposalVector[4] = Math.round(weightedAverageProposalVector[4]); //weeklyScale média
						
						//console.info("weightedAverageProposalVector[4]: ");
						//console.log(weightedAverageProposalVector[4]);
						
						
                        resultMessage += `Média Ponderada dos Vetores Propostas: ${weightedAverageProposalVector.join(", ")}`;

                        if (productionUnit.estoqueDemanda && Array.isArray(productionUnit.estoqueDemanda)) {
                            const inputTechnologicalMatrixTableBody = document.getElementById('inputTechnologicalMatrixTableBody');
							
							const inputFinalDemandTableBody = document.getElementById('finalDemandInputs');

                            if (inputTechnologicalMatrixTableBody.rows.length >= weightedAverageTechnologicalVector.length + 1) {
							
                                productionUnit.estoqueDemanda.forEach((estoqueDemandaRow, index) => {
                                    const bemDeProducao = estoqueDemandaRow.bemDeProducao.trim();
									
                                    const matchingTechnologicalRow = Array.from(inputTechnologicalMatrixTableBody.rows).find(r => r.cells[0].querySelector('input').value.trim() === bemDeProducao);
									
									const matchingFinalDemandRow = Array.from(inputFinalDemandTableBody.rows).find(r => r.cells[0].textContent.trim() === bemDeProducao);
									
									const thead = document.getElementById('inputTable').querySelector('thead');
                                    const sectorHeaders = thead.querySelectorAll('th input');
                                    const setorColIndex = Array.from(sectorHeaders).findIndex(input => input.value.includes(setorUnidade)) + 1;

                                    if (matchingTechnologicalRow && matchingTechnologicalRow.cells[setorColIndex]?.querySelector('input')) {
                                    
									//Estimativas na Matriz Tecnológica
									matchingTechnologicalRow.cells[setorColIndex].querySelector('input').value = weightedAverageTechnologicalVector[index];
																		
									//console.info(`weightedAverageDemandVector[${index}]`);
									//console.log(weightedAverageDemandVector[index]);
									
									//Estimativa no vetor Demanda Final 
									matchingFinalDemandRow.cells[1].querySelector('input').value = weightedAverageDemandVector[index];
									
									//Estimativas na janela modal "Otimização"									
									document.getElementById('workerLimit').value = weightedAverageProposalVector[0];
									document.getElementById('workerHours').value = weightedAverageProposalVector[1];
									document.getElementById('productionTime').value = weightedAverageProposalVector[2];
									document.getElementById('nightShift').checked = weightedAverageProposalVector[3];
									document.getElementById('weeklyScale').value = weightedAverageProposalVector[4];
									
									currentProductIndex = productIndex;
									
									//Salvar modal (pra ajustar botão inclusive)
									setTimeout(() => {
										saveOptimizationInputs();
									}, 3000);
										
                                    } else {
                                        showNotification(`Cadastre o produto ${bemDeProducao}, pois é um bem de produção do setor ${setorUnidade}.`, false);
                                    }
                                });
								
                            } else {
                                resultMessage = `A Matriz Tecnológica não possui a mesma quantidade de produtos mínima usados como bens de produção do setor ${setorUnidade}. Deve possuir no mínimo ${weightedAverageTechnologicalVector.length + 1} linhas (ou produtos). Cadastre os bens de produção desse setor.`;
								showNotification(resultMessage, false);
                            }
                        }
                    }
                } else {
                    //resultMessage = `Nenhum vetor tecnológico encontrado para o setor ${setorUnidade}.`;
                }

                console.info(resultMessage);
            });
        } else {
            console.error("data não é um objeto válido.");
            alert("Ocorreu um erro ao processar os dados. Tente novamente.");
        }
    } catch (error) {
        console.error("Erro ao buscar vetores tecnológicos:", error);
        alert("Ocorreu um erro ao buscar os vetores tecnológicos. Por favor, tente novamente.");
    }
}

function updateDemandAndGoal() {
	
	
	const confirmation = confirm("Você salvou alterações que tenha feito aqui?");
	if (!confirmation) {
		showNotification("Salve as alterações que fez aqui." ,false);
		return;
	}
	
    // Obter a chave da instância a partir do campo "Conselho Popular Associado:"
    const instanceKey = document.getElementById("conselhoPopularAssociadoDeComiteOuTrabalhador").value.trim();
    const targetProduct = document.querySelector("#producaoMetaTable tbody tr input[type='text']").value.trim();

    if (!instanceKey) {
        console.error("Conselho Popular Associado não preenchido.");
        return;
    }

    fetch(apiUrl, {
		method: 'GET',
		headers: headers
	})
		.then(response => response.json())
		.then(binData => {
            const record = binData || {};
            const instanceData = record[instanceKey];

            if (instanceData) {
                const { optimizationResults, productNames, setorUnidade } = instanceData; //CARREGAR plannedFinalDemand

                // Encontrar índice do produto no vetor "productNames"
                const productIndex = productNames.indexOf(targetProduct);

                if (productIndex !== -1 && optimizationResults) {
                    // Localizar o valor correspondente no vetor "optimizationResults"
					//console.info("optimizationResults: ");
					//console.log(optimizationResults);
					//console.info("productIndex: ");
					//console.log(productIndex);
                    const requiredProduction = optimizationResults[productIndex].plannedFinalDemand;

					//console.info("requiredProduction: ");
					//console.log(requiredProduction);

                    // Filtrar as unidades de produção do setor atual
                    const filteredRecords = Object.values(record).filter(item =>
                        item.conselhoPopularAssociadoDeComiteOuTrabalhador === instanceKey &&
                        item.setorUnidade === `Produção de ${targetProduct}`
                    );

                    // Calcular o totalEffectiveWorkersLimit
                    let totalEffectiveWorkersLimit = 0;
                    filteredRecords.forEach(productionUnit => {
                        if (productionUnit.limiteEfetivoTrabalhadores) {
                            totalEffectiveWorkersLimit += parseInt(productionUnit.limiteEfetivoTrabalhadores, 10);
                        }
                    });

                    if (totalEffectiveWorkersLimit === 0) {
                        console.error("Nenhum trabalhador efetivo encontrado nas unidades de produção filtradas.");
                        return;
                    }

                    // Obter o totalEffectiveWorkers da interface
                    const totalEffectiveWorkers = parseFloat(document.getElementById("limiteEfetivoTrabalhadores").value.trim()) || 0;

                    // Calcular o peso da unidade de produção
                    const productionUnitWeight = totalEffectiveWorkers / totalEffectiveWorkersLimit;

					let sociallyDeterminedProductionGoal = productionUnitWeight*requiredProduction;
					//console.info("requiredProduction: ");
					//console.log(requiredProduction);
					let producedQuantity = 5;
					let pendingProductionQuantity = ((sociallyDeterminedProductionGoal-producedQuantity*1000)/1000).toFixed(3); //divide por 1000 só pra dar a ordem de grandeza, mas pode mudar isso
					
					document.getElementById("pendingProductionQuantity").value = pendingProductionQuantity;

					// Adição: Iteração nas tabelas "Estoque e Demanda" e "Vetor Tecnológico"
                    const stockDemandTable = document.querySelector("#estoqueDemandaTable tbody");
                    const techVectorTable = document.querySelector("#vetorTecnologicoTable tbody");

                    if (stockDemandTable && techVectorTable) {
                        const stockRows = stockDemandTable.rows;
                        const techRows = techVectorTable.rows;

                        for (let i = 0; i < stockRows.length && i < techRows.length; i++) {
                            // Obter valores das colunas relevantes
                            const quantidadeDeUmBemDeProducao = parseFloat(techRows[i].cells[1].querySelector("input").value) || 0;
                            const estoqueDeUmBemDeProducao = parseFloat(stockRows[i].cells[1].querySelector("input").value) || 0;

                            // Calcular demanda de um bem de produção
                            const demandaDeUmBemDeProducao = 
                                quantidadeDeUmBemDeProducao * pendingProductionQuantity - estoqueDeUmBemDeProducao;

                            // Atualizar a coluna correspondente na tabela "Estoque e Demanda"
                            stockRows[i].cells[2].querySelector("input").value = demandaDeUmBemDeProducao.toFixed(3);
                        }
                    }

                    // Exibir os resultados no console
                    console.log("Required production to meet final demand:", requiredProduction);
                    console.log("Total Effective Workers Limit:", totalEffectiveWorkersLimit);
                    console.log("Production Unit Weight:", productionUnitWeight);
					console.log("sociallyDeterminedProductionGoal:", sociallyDeterminedProductionGoal);
					console.log("producedQuantity:", producedQuantity);
					console.log("pendingProductionQuantity:", pendingProductionQuantity);
					
					
					
					
                } else {
                    console.error("Produto ou demanda final não encontrada.");
                }
            } else {
                console.error("Nenhum dado encontrado para a instância:", instanceKey);
            }
        })
        .catch(err => console.error("Erro ao carregar dados do JSONBin:", err));

    // Rolar para o final da página
    scrollToEndOfPage();
}

function addTooltipBehavior(inputElement) {
    inputElement.addEventListener('mouseenter', (e) => {
        const value = e.target.value;

        // Cria o tooltip
        const tooltip = document.createElement('div');
        tooltip.className = 'custom-tooltip';
        tooltip.textContent = value;
        document.body.appendChild(tooltip);

        // Calcula a posição do tooltip
        const rect = e.target.getBoundingClientRect();
        tooltip.style.left = `${rect.left + window.scrollX + rect.width / 2 - tooltip.offsetWidth / 2}px`;
        tooltip.style.top = `${rect.top + window.scrollY - tooltip.offsetHeight - 8}px`;
    });

    inputElement.addEventListener('mouseleave', () => {
        // Remove o tooltip ao sair
        const tooltip = document.querySelector('.custom-tooltip');
        if (tooltip) {
            tooltip.remove();
        }
    });
}

document.addEventListener('DOMContentLoaded', () => {
    let isDragging = false; // Verifica se o usuário está arrastando
    let startX = 0, startY = 0; // Posição inicial do mouse
    let scrollLeft = 0, scrollTop = 0; // Posição inicial de rolagem
    let velocityX = 0, velocityY = 0; // Velocidade de rolagem

    document.body.style.cursor = 'default'; // Cursor padrão

    document.addEventListener('mousedown', (e) => {

        isDragging = true;
        startX = e.pageX; // Posição X inicial
        startY = e.pageY; // Posição Y inicial
        scrollLeft = window.scrollX; // Posição inicial de rolagem horizontal
        scrollTop = window.scrollY; // Posição inicial de rolagem vertical

        velocityX = 0;
        velocityY = 0;

        document.body.style.cursor = 'move'; // Muda o cursor para "move"
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return; // Só funciona enquanto arrastando

        // Calcula o quanto o mouse se moveu
        const moveX = startX - e.pageX;
        const moveY = startY - e.pageY;

        velocityX = moveX * 0.05; // Ajuste de sensibilidade
        velocityY = moveY * 0.05;
    });

    document.addEventListener('mouseup', () => {
        isDragging = false; // Termina o arraste
        document.body.style.cursor = 'default'; // Restaura o cursor padrão
    });

    // Suaviza a rolagem
    function smoothScroll() {
        if (!isDragging) {
            // Diminui gradualmente a velocidade quando o mouse não está arrastando
            velocityX *= 0.98; // Ajuste de desaceleração
            velocityY *= 0.98;
        }

        // Atualiza a posição da rolagem
        window.scrollBy(velocityX, velocityY);

        // Para o loop quando o movimento for insignificante
        if (Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1) {
            requestAnimationFrame(smoothScroll);
        }
    }

    // Inicia a suavização contínua
    document.addEventListener('mousemove', () => {
        if (isDragging || Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1) {
            requestAnimationFrame(smoothScroll);
        }
    });
});


function addHighlightBehavior(cell) {
    cell.addEventListener('mouseover', () => {
        const table = document.getElementById('inputTable');
        const row = cell.parentElement;
        const cellIndex = Array.from(row.children).indexOf(cell);

        // Destaca a coluna
        Array.from(table.rows).forEach(row => {
            if (row.cells[cellIndex]) {
                row.cells[cellIndex].classList.add('highlight-column');
            }
        });
    });

    cell.addEventListener('mouseout', () => {
        const table = document.getElementById('inputTable');
        const row = cell.parentElement;
        const cellIndex = Array.from(row.children).indexOf(cell);

        // Remove o destaque da coluna
        Array.from(table.rows).forEach(row => {
            if (row.cells[cellIndex]) {
                row.cells[cellIndex].classList.remove('highlight-column');
            }
        });
    });
}

 // Alterna o menu de idiomas e o posiciona próximo ao botão
    function toggleLanguageMenu(event) {
        const menu = document.getElementById('languageMenu');
        const button = event.currentTarget;

        if (menu.style.display === 'none' || menu.style.display === '') {
            const rect = button.getBoundingClientRect();
            menu.style.top = `${rect.bottom + window.scrollY}px`;
            menu.style.left = `${rect.left + window.scrollX}px`;
            menu.style.display = 'block';
        } else {
            menu.style.display = 'none';
        }
    }

    function translatePage(language) { 
    // Dicionário com traduções da mensagem
    const translations = {
        en: "Functionality under development. But as a suggestion, you can use your browser's native translator.",
        pt: "Funcionalidade em desenvolvimento. Mas como sugestão, você pode usar o tradutor nativo do seu navegador.",
        es: "Funcionalidad en desarrollo. Pero como sugerencia, puedes utilizar el traductor nativo de tu navegador.",
        fr: "Fonctionnalité en cours de développement. Mais à titre de suggestion, vous pouvez utiliser le traducteur natif de votre navigateur.",
        zh: "功能正在开发中。但建议您使用浏览器的本机翻译器。",
        ru: "Функционал в разработке. Но в качестве предложения вы можете использовать встроенный переводчик вашего браузера.",
        ar: "وظائف قيد التطوير. ولكن كاقتراح، يمكنك استخدام المترجم الأصلي للمتصفح الخاص بك.",
        yo: "Iṣẹ ṣiṣe labẹ idagbasoke. Ṣugbọn gẹgẹbi imọran, o le lo onitumọ abinibi ti aṣawakiri rẹ."
    };

    // Obtém a mensagem traduzida com base no idioma selecionado
    const message = translations[language] || translations.en; // Default para inglês se o idioma não for encontrado

    // Altera o idioma da página
    document.documentElement.lang = language;

    // Notifica o usuário sobre como ativar a tradução
    showNotification(message);

    // Oculta o menu de idiomas
    document.getElementById('languageMenu').style.display = 'none';
}

function openOptimizationModalEstimates(productIndex, optimizationInputsLocal) {
    // Se optimizationInputsLocal for passado, use-o. Caso contrário, chame a função original
	
	optimizationInputs = optimizationInputsLocal;
	
	//console.info("optimizationInputs na openOptimizationModal: ");
	//console.log(optimizationInputs);
	
    //Chama a função original
    openOptimizationModal(productIndex);
}

function generateUUID() {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let uuidBase = '';

    // Gera os primeiros 22 caracteres do UUID (Base64-like)
    for (let i = 0; i < 22; i++) {
        uuidBase += characters.charAt(Math.floor(Math.random() * characters.length));
    }

    // Gera os 2 dígitos verificadores
    const checksum = generateUUIDChecksum(uuidBase);

    // Retorna o UUID completo (22 caracteres + 2 dígitos verificadores)
	let uuid = uuidBase + checksum;
	
	//console.info("uuid: ");
	//console.log(uuid);
	
    return uuid;
}

function generateUUIDChecksum(uuidBase) {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let sum = 0;

    // Calcula a soma ponderada dos caracteres
    for (let i = 0; i < uuidBase.length; i++) {
        const char = uuidBase[i];
        const value = characters.indexOf(char); // Índice no conjunto de caracteres
        sum += value * (i + 1); // Ponderação baseada na posição (1-based)
    }

    // Gera 2 caracteres alfanuméricos para o checksum
    const checksumValue1 = sum % 62; // Primeiro caractere do checksum
    const checksumValue2 = Math.floor(sum / 62) % 62; // Segundo caractere do checksum

    return characters[checksumValue1] + characters[checksumValue2];
}

function validateUUID(uuid) {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

    // Verifica o comprimento total do UUID (22 caracteres + 2 dígitos verificadores)
    if (uuid.length !== 24) return false;

    // Extrai a base e o checksum do UUID
    const uuidBase = uuid.slice(0, 22); // Primeiros 22 caracteres
    const checksum = uuid.slice(22);   // Últimos 2 caracteres

    // Recalcula o checksum com base na base do UUID
    const calculatedChecksum = generateUUIDChecksum(uuidBase);

    // Compara o checksum fornecido com o recalculado
    return checksum === calculatedChecksum;
}


		function generateQRCode(data) {
            const qrCodeDiv = document.getElementById("uuidQRCode");

            // Limpa qualquer QR Code anterior
            qrCodeDiv.innerHTML = "";

            // Gera o QR Code diretamente na div
            new QRCode(qrCodeDiv, {
                text: data,
                width: 200,
                height: 200,
                colorDark: "#000000", // Cor do QR Code
                colorLight: "#ffffff", // Cor de fundo
                correctLevel: 2 // Nível de correção de erros
            });
			
        }


		</script>
	</body>
	</html>
